{"version":3,"file":"js/312.97c449f7.js","mappings":"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","sources":["webpack://cubing-trivia/../../src/cubing/puzzle-geometry/FaceNameSwizzler.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/Options.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/Perm.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/PermOriSet.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/PGPuzzles.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/Quat.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/PlatonicGenerator.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/SchreierSims.ts","webpack://cubing-trivia/../../src/cubing/puzzle-geometry/PuzzleGeometry.ts"],"sourcesContent":["// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(public facenames: string[], gripnames_arg?: string[]) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(\"Could not split \" + s + \" into face names.\");\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /* same as above, but permit both to have v's on the end. */\n  public spinmatchv(userinput: string, longname: string): boolean {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(\n        userinput.slice(0, userinput.length - 1),\n        longname.slice(0, longname.length - 1),\n      );\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n","import type { Move } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(move: Move): Move | null {\n    return move;\n  }\n\n  public notationToExternal(move: Move): Move | null {\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FTONotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper, private sw: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (\n      move.family === \"T\" &&\n      move.innerLayer === undefined &&\n      move.outerLayer === undefined\n    ) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(move: Move, a: FaceNameSwizzler, b: FaceNameSwizzler): Move {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n  }\n\n  public notationToInternal(move: Move): Move {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n}\n","// Sits on top of a (possibly null) notation mapper, and\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer === undefined && move.outerLayer === undefined) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n\n        // TODO: Figure out if `cubing/alg` should parse `R++` to a family of `R++`.\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    if (move.family === \"Dv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.amount,\n          );\n        }\n      }\n    }\n    return move;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst pyraminxFamilyMap: Record<string, string> = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n};\nconst tetraminxFamilyMap: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\",\n};\n\nconst pyraminxFamilyMapWCA: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n};\n\nconst pyraminxExternalQuantumY = new QuantumMove(\"y\");\nconst pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\n\nexport class PyraminxNotationMapper implements NotationMapper {\n  protected wcaHack: boolean = false;\n  map: Record<string, string> = pyraminxFamilyMap;\n\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(\n          new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    const newFamily = this.map[move.family];\n\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(\n            new QuantumMove(external, move.innerLayer, move.outerLayer),\n            move.amount,\n          );\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class TetraminxNotationMapper extends PyraminxNotationMapper {\n  wcaHack = true;\n\n  constructor(child: FaceNameSwizzler) {\n    super(child);\n    this.map = tetraminxFamilyMap;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst skewbFamilyMap: Record<string, string> = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\",\n};\n\n// TODO: combine using a similar table.\nconst skewbExternalQuantumX = new QuantumMove(\"x\");\nconst skewbInternalQuantumX = new QuantumMove(\"Rv\");\nconst skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nconst skewbExternalQuantumY = new QuantumMove(\"y\");\nconst skewbInternalQuantumY = new QuantumMove(\"Uv\");\nconst skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nconst skewbExternalQuantumZ = new QuantumMove(\"z\");\nconst skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nconst skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\n\nexport class SkewbNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.outerLayer, move.innerLayer),\n        move.amount,\n      );\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n    /*\n       *   (1) We are not including x/y/z in Skewb; they aren't WCA notation and\n       *   it's unclear anyone needs them for reconstructions.\n       *\n    } else if (move.family === \"x\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Rv\", move.amount);\n    } else if (move.family === \"y\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Uv\", move.amount);\n    } else if (move.family === \"z\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Fv\", move.amount);\n       */\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n    /*\n       *   See (1) above.\n       *\n    if (move.family === \"Rv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"x\", move.amount);\n    } else if (move.family === \"Uv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"y\", move.amount);\n    } else if (move.family === \"Fv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"z\", move.amount);\n       */\n    // } else {\n    //   return null;\n    // }\n  }\n}\n","import { parsePuzzleDescription, PuzzleDescription } from \"./PuzzleGeometry\";\n\nexport function parseOptions(argv: string[]): {\n  puzzleDescription: PuzzleDescription | null;\n  options: PuzzleGeometryOptions;\n} {\n  let argp = 0;\n  const options: PuzzleGeometryOptions = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]); // TODO: Validate input.\n      argp++;\n    } else {\n      throw new Error(\"Bad option: \" + option);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\n\ntype FaceName = string;\ntype OrientationDirection = [number, number, number];\nexport type FaceBasedOrientationDescription = [\n  [FaceName, OrientationDirection],\n  [FaceName, OrientationDirection],\n];\nexport type BaseFaceCount = 4 | 6 | 8 | 12 | 20;\nexport type FaceBasedOrientationDescriptionLookup = Record<\n  BaseFaceCount,\n  FaceBasedOrientationDescription\n>;\n\nfunction asstructured(v: any): any {\n  if (typeof v === \"string\") {\n    return JSON.parse(v);\n  }\n  return v;\n}\nfunction asboolean(v: any): boolean {\n  if (typeof v === \"string\") {\n    if (v === \"false\") {\n      return false;\n    }\n    return true;\n  } else {\n    return v ? true : false;\n  }\n}\n\nexport class PuzzleGeometryFullOptions {\n  verbosity: number = 0; // verbosity (console.log)\n\n  allMoves: boolean = false; // generate all slice moves in ksolve\n  outerBlockMoves: boolean; // generate outer block moves\n  vertexMoves: boolean = false; // generate vertex moves\n  addRotations: boolean = false; // add symmetry information to ksolve output\n  moveList: string[] | null = null; // move list to generate\n\n  fixedOrientation: boolean = false; // eliminate any orientations\n  fixedPieceType: null | \"e\" | \"v\" | \"f\" = null; // fix a piece?\n  orientCenters: boolean = false; // orient centers?\n\n  // TODO: Group these into a single object?\n  includeCornerOrbits: boolean = true; // include corner orbits\n  includeCenterOrbits: boolean = true; // include center orbits\n  includeEdgeOrbits: boolean = true; // include edge orbits\n  // Overrides the previous options.\n  excludeOrbits: string[] = []; // exclude these orbits\n  optimizeOrbits: boolean = false; // optimize PermOri\n\n  grayCorners: boolean = false; // make corner sets gray\n  grayCenters: boolean = false; // make center sets gray\n  grayEdges: boolean = false; // make edge sets gray\n\n  puzzleOrientation: FaceBasedOrientationDescription | null = null; // single puzzle orientation from options\n  puzzleOrientations: FaceBasedOrientationDescriptionLookup | null = null; // puzzle orientation override object from options // TODO: is this needed?\n\n  scrambleAmount: number = 0; // scramble?\n\n  constructor(options: PuzzleGeometryOptions = {}) {\n    Object.assign(this, options);\n  }\n}\n\nexport type PuzzleGeometryOptions = Partial<PuzzleGeometryFullOptions>;\n\nexport function parsePGOptionList(optionlist?: any[]): PuzzleGeometryOptions {\n  const options: PuzzleGeometryOptions = {};\n  if (optionlist !== undefined) {\n    if (optionlist.length % 2 !== 0) {\n      throw new Error(\"Odd length in option list?\");\n    }\n    for (let i = 0; i < optionlist.length; i += 2) {\n      if (optionlist[i] === \"verbose\") {\n        options.verbosity = (options.verbosity ?? 0) + 1;\n      } else if (optionlist[i] === \"quiet\") {\n        options.verbosity = 0;\n      } else if (optionlist[i] === \"allmoves\") {\n        options.allMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"outerblockmoves\") {\n        options.outerBlockMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"vertexmoves\") {\n        options.vertexMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"rotations\") {\n        options.addRotations = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"cornersets\") {\n        options.includeCornerOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"centersets\") {\n        options.includeCenterOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"edgesets\") {\n        options.includeEdgeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"omit\") {\n        options.excludeOrbits = optionlist[i + 1];\n      } else if (optionlist[i] === \"graycorners\") {\n        options.grayCorners = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"graycenters\") {\n        options.grayCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"grayedges\") {\n        options.grayEdges = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"movelist\") {\n        options.moveList = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"killorientation\") {\n        options.fixedOrientation = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"optimize\") {\n        options.optimizeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"scramble\") {\n        options.scrambleAmount = optionlist[i + 1];\n      } else if (optionlist[i] === \"fix\") {\n        options.fixedPieceType = optionlist[i + 1];\n      } else if (optionlist[i] === \"orientcenters\") {\n        options.orientCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientation\") {\n        options.puzzleOrientation = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientations\") {\n        options.puzzleOrientations = asstructured(optionlist[i + 1]);\n      } else {\n        throw new Error(\n          \"Bad option while processing option list \" + optionlist[i],\n        );\n      }\n    }\n  }\n  return options;\n}\n","const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): bigint {\n  let r = 1n;\n  while (a > 1) {\n    r *= BigInt(a);\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","import { Move } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\"; // TODO\nimport { NullMapper } from \"./notation-mapping\";\nimport type { NotationMapper } from \"./notation-mapping/NotationMapper\";\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class PGOrbitDef {\n  constructor(public size: number, public mod: number) {}\n  public reassemblySize(): bigint {\n    return factorial(this.size) * BigInt(this.mod) ** BigInt(this.size);\n  }\n}\n\nlet lastGlobalDefinitionCounter = 0;\n\nexport function externalName(\n  mapper: NotationMapper,\n  moveString: string,\n): string {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\n\nexport class PGOrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    private orbitdefs: PGOrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: PGTransform[],\n  ) {}\n\n  public transformToKTransformationData(t: PGTransform): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  public static transformToKTransformationData(\n    orbitnames: string[],\n    t: PGTransform,\n  ): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  public toKsolve(\n    name: string,\n    mapper: NotationMapper = new NullMapper(),\n  ): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        `Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`,\n      );\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(\n        result,\n        this.orbitnames[i],\n        false,\n        false,\n      );\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name = externalName(mapper, this.movenames[i]);\n      let doinv = false;\n      if (name[name.length - 1] === \"'\") {\n        doinv = true;\n        name = name.substring(0, name.length - 1);\n      }\n      result.push(\"Move \" + name);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j]\n            .inv()\n            .appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(\n            result,\n            this.orbitnames[j],\n            true,\n          );\n        }\n      }\n      result.push(\"End\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition {\n    const orbits: KPuzzleDefinition[\"orbits\"] = {};\n    const start: KPuzzleDefinition[\"startStateData\"] = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod,\n      };\n      const startTransformation = this.solved.orbits[i].toKPuzzle();\n      start[this.orbitnames[i]] = {\n        pieces: startTransformation.permutation,\n        orientation: startTransformation.orientation,\n      };\n    }\n    const moves: { [moveName: string]: any } = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.transformToKTransformationData(\n          this.moveops[i],\n        );\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      startStateData: start,\n      moves,\n    };\n  }\n\n  public optimize(): PGOrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: PGOrbitDef[] = [];\n    const newsolved: PGOrbit[] = [];\n    const newmoveops: PGOrbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (\n            this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0\n          ) {\n            changed[k] = true;\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new PGOrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new PGTransform(_)),\n    );\n  }\n\n  // replace the solved state with a new scrambled state.\n  public scramble(n: number): void {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n\n  // generate a new \"random\" position based on an entropy pool\n  // this should be significantly faster and more random than just\n  // doing a large number of random moves, especially on big puzzles.\n  public getScrambleTransformation(n: number): PGTransform {\n    // don't let n be too tiny\n    if (n < 100) {\n      n = 100;\n    }\n    const pool: PGTransform[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n\n  public reassemblySize(): bigint {\n    let n = 1n;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\n\nexport class PGOrbit {\n  private static kcache: Record<string, number[]>[] = [];\n\n  public static e(n: number, mod: number): PGOrbit {\n    return new PGOrbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: PGOrbit): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new PGOrbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new PGOrbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: PGOrbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private zeroOris(): boolean {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public appendDefinition(\n    result: string[],\n    name: string,\n    useVS: boolean,\n    concise: boolean = true,\n  ): void {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_: number) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array<number>(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n\n  // TODO: return type\n  public toKPuzzle(): Record<string, number[]> {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!PGOrbit.kcache[n]) {\n        PGOrbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };\n      }\n      return PGOrbit.kcache[n];\n    } else {\n      return { permutation: this.perm, orientation: this.ori };\n    }\n  }\n}\nexport class PGTransformBase {\n  constructor(public orbits: PGOrbit[]) {}\n  public internalMul(b: PGTransformBase): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  protected internalInv(): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: PGTransformBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected killOri(): this {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n}\nexport class PGTransform extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): PGTransform {\n    return new PGTransform(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): PGTransform {\n    if (n === 0) {\n      return this.e();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let t: PGTransform = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): PGTransform {\n    return new PGTransform(this.internalInv());\n  }\n\n  public e(): PGTransform {\n    return new PGTransform(\n      this.orbits.map((_: PGOrbit) => PGOrbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  private heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"0: canonseq 1\");\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(`${d}\": canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n","export type PuzzleDescriptionString = string;\n\nexport const PGPuzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\":\n    \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"tetraminx\": \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"teraminx\": \"d f 0.64 f 0.76 f 0.88\",\n  \"petaminx\": \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  \"examinx\": \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  \"zetaminx\": \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  \"yottaminx\": \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  \"pentultimate\": \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  \"starminx\": \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport type PuzzleName = keyof typeof PGPuzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  public cutface(face: Quat[]): Quat[][] | null {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << (this.side(face[i].dot(this) - d) + 1);\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      // saw both sides\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face: Quat[] = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): bigint {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): bigint {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1n;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1n;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= BigInt(cnt);\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        `${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`,\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\n","import { Move, QuantumMove } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport {\n  FaceRenamingMapper,\n  FTONotationMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n  PyraminxNotationMapper,\n  SkewbNotationMapper,\n  TetraminxNotationMapper,\n} from \"./notation-mapping\";\nimport {\n  BaseFaceCount,\n  FaceBasedOrientationDescription,\n  FaceBasedOrientationDescriptionLookup,\n  PuzzleGeometryFullOptions,\n  PuzzleGeometryOptions,\n} from \"./Options\";\nimport { iota, Perm, zeros } from \"./Perm\";\nimport {\n  externalName,\n  PGOrbit,\n  PGOrbitDef,\n  PGOrbitsDef,\n  PGTransform,\n  showcanon,\n  VisibleState,\n} from \"./PermOriSet\";\nimport { PGPuzzles, PuzzleDescriptionString, PuzzleName } from \"./PGPuzzles\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { centermassface, Quat } from \"./Quat\";\nimport { schreierSims } from \"./SchreierSims\";\n\nexport interface TextureMapper {\n  getuv(fn: number, threed: number[]): number[];\n}\n\nexport interface StickerDatSticker {\n  coords: number[];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n  face: number;\n  isDup?: boolean;\n}\n\nexport interface StickerDatFace {\n  coords: number[];\n  name: string;\n}\n\nexport type StickerDatAxis = {\n  coordinates: number[];\n  quantumMove: Move;\n  order: number;\n};\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: Move): Move | null;\n  notationMapper: NotationMapper;\n  textureMapper: TextureMapper;\n}\n\n// you can fill these in to help with timing if you want\nfunction tstart(s: string): string {\n  return s;\n}\n\nfunction tend(_: string): void {}\n\nclass Face {\n  private coords: number[];\n  public length: number;\n  constructor(q: Quat[]) {\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n\n  get(off: number): Quat {\n    return new Quat(\n      0,\n      this.coords[3 * off],\n      this.coords[3 * off + 1],\n      this.coords[3 * off + 2],\n    );\n  }\n\n  centermass(): Quat {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n\n  rotate(q: Quat): Face {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new Face(a);\n  }\n\n  rotateforward(): Face {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new Face(a);\n  }\n}\n\nexport class FaceTree {\n  constructor(\n    private face: Quat[],\n    private left?: FaceTree,\n    private right?: FaceTree,\n  ) {}\n\n  public split(q: Quat): FaceTree {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === undefined) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n\n  public collect(arr: Face[], leftfirst: boolean): Face[] {\n    if (this.left === undefined) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n}\n\nexport function expandfaces(rots: Quat[], faces: Face[]): Face[] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\",\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\",\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\",\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\n// TODO: change this back to a const JSON definition.\nfunction defaultfaceorders(): any {\n  return {\n    4: [\"F\", \"D\", \"L\", \"R\"],\n    6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n    8: [\"F\", \"BB\", \"D\", \"U\", \"BR\", \"L\", \"R\", \"BL\"],\n    12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\", \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n    20: [\n      \"L\",\n      \"S\",\n      \"E\",\n      \"O\",\n      \"F\",\n      \"B\",\n      \"I\",\n      \"P\",\n      \"R\",\n      \"K\",\n      \"U\",\n      \"D\",\n      \"J\",\n      \"A\",\n      \"Q\",\n      \"H\",\n      \"G\",\n      \"N\",\n      \"M\",\n      \"C\",\n    ],\n  };\n}\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): FaceBasedOrientationDescriptionLookup {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLR towards viewer\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // URF towards viewer\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLUR towards viewer\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n  };\n}\n\nfunction findelement(a: Quat[][], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getPG3DNamedPuzzles(): {\n  [s: string]: PuzzleDescriptionString;\n} {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles;\n}\n\nexport function getPuzzleDescriptionString(\n  puzzleName: PuzzleName,\n): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles[puzzleName];\n}\n\nexport const PUZZLE_BASE_SHAPES = [\"c\", \"t\", \"o\", \"d\", \"i\"] as const;\nexport type PuzzleBaseShape = typeof PUZZLE_BASE_SHAPES[number];\n\nexport const PUZZLE_CUT_TYPES = [\"f\", \"v\", \"e\"] as const;\nexport type PuzzleCutType = typeof PUZZLE_CUT_TYPES[number];\n\nexport type PuzzleCutDescription = { cutType: PuzzleCutType; distance: number };\nexport type PuzzleDescription = {\n  shape: PuzzleBaseShape;\n  cuts: PuzzleCutDescription[];\n};\n\nexport function parsePuzzleDescription(\n  s: PuzzleDescriptionString,\n): PuzzleDescription | null {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (\n    shape !== \"o\" &&\n    shape !== \"c\" &&\n    shape !== \"i\" &&\n    shape !== \"d\" &&\n    shape !== \"t\"\n  ) {\n    return null;\n  }\n  const cuts: PuzzleCutDescription[] = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({\n      cutType: a[i] as PuzzleCutType,\n      distance: parseFloat(a[i + 1]),\n    });\n  }\n  return { shape, cuts };\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: PuzzleGeometryOptions = {},\n): PuzzleGeometry {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw new Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(\n    parsed,\n    Object.assign({}, { allMoves: true } as PuzzleGeometryOptions, options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options?: PuzzleGeometryOptions,\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\n\nfunction getmovename(\n  geo: any,\n  bits: number[],\n  slices: number,\n): [string, boolean] {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0] as string;\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw `We only support slice and outer block moves right now. ${bits}`;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: [Quat[], string][]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (\n        s.substr(at).startsWith(facename[1]) &&\n        facename[1].length > currentMatch.length\n      ) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(\"Could not split \" + s + \" into face names.\");\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Face, maxdist: number): number[] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\n\nexport class PuzzleGeometry {\n  private rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  private baseplanes: Quat[]; // planes, corresponding to faces\n  private facenames: [Quat[], string][]; // face names\n  private faceplanes: [Quat, string][]; // face planes\n  private edgenames: [Quat, string][]; // edge names\n  private vertexnames: [Quat, string][]; // vertexnames\n  private geonormals: [Quat, string, string][]; // all geometric directions, with names and types\n  private moveplanes: Quat[]; // the planes that split moves\n  private moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: Quat[][]; // the move planes, in parallel sets\n  private moveplanenormals: Quat[]; // one move plane\n  public movesetorders: number[]; // the order of rotations for each move set\n  public movesetgeos: [string, string, string, string, number][]; // geometric feature information for move sets\n  private basefaces: Face[]; // polytope faces before cuts\n  private faces: Face[]; // all the stickers\n  private facecentermass: Quat[]; // center of mass of all faces\n  private baseFaceCount: BaseFaceCount; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public shortedge: number; // number of stickers per face\n  public cubies: number[][]; // the cubies\n  private vertexdistance: number; // vertex distance\n  private edgedistance: number; // edge distance\n  private facetocubie: number[]; // map a face to a cubie index\n  private facetoord: number[]; // map a face to a cubie ord\n  private moverotations: Quat[][]; // move rotations\n  private facelisthash: Map<string, number[]>; // face list by key\n  private cubiesetnames: string[]; // cubie set names\n  private cubieords: number[]; // the size of each orbit\n  private cubiesetnums: number[];\n  private cubieordnums: number[];\n  private orbitoris: number[]; // the orientation size of each orbit\n  private cubievaluemap: number[]; // the map for identical cubies\n  private cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  public parsedmovelist: [\n    string | undefined,\n    number,\n    number,\n    number,\n    boolean,\n    number,\n  ][]; // parsed move list\n\n  private duplicatedFaces: number[] = []; // which faces are duplicated\n  private duplicatedCubies: number[] = []; // which cubies are duplicated\n  private fixedCubie: number = -1; // fixed cubie, if any\n  private net: string[][] = [];\n  private colors: any = [];\n  private faceorder: string[] = [];\n  private faceprecedence: number[] = [];\n  private swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  private addNotationMapper: string = \"\";\n  private setReidOrder: boolean = false;\n\n  private options: PuzzleGeometryFullOptions;\n\n  constructor(\n    public puzzleDescription: PuzzleDescription,\n    options: PuzzleGeometryOptions,\n  ) {\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(puzzleDescription);\n    tend(t1);\n  }\n\n  public create(puzzleDescription: PuzzleDescription): void {\n    const { shape, cuts } = puzzleDescription;\n\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\":\n        g = cube();\n        break;\n      case \"o\":\n        g = octahedron();\n        break;\n      case \"i\":\n        g = icosahedron();\n        break;\n      case \"t\":\n        g = tetrahedron();\n        break;\n      case \"d\":\n        g = dodecahedron();\n        break;\n      default:\n        throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(\"# Rotations: \" + this.rotations.length);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.baseFaceCount = baseplanes.length as BaseFaceCount;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    this.faceorder = defaultfaceorders()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(\"# Base planes: \" + baseplanes.length);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Face vertices: \" + baseface.length);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Boundary is \" + boundary);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgedistance = firstface[0].sum(firstface[1]).smul(0.5).dist(zero);\n    this.vertexdistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\":\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        case \"v\":\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        case \"e\":\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        default:\n          throw new Error(\"Bad cut argument: \" + cut.cutType);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (const baseplanerot of this.baseplanerot) {\n      const face = baseplanerot.rotateface(firstface);\n      this.basefaces.push(new Face(face));\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: [Quat[], string][] = [];\n    const faceplanes: [Quat, string][] = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (const el of a) {\n        if (el[0].dist(p) < eps) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: string[] = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== neti[j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\n          \"Could not find face \" +\n            faceindextoname[i] +\n            \" in face order list \" +\n            this.faceorder,\n        );\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (\n        this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]\n      ) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; counterclockwise rotations; low face first.\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (\n          this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]\n        ) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.options.verbosity > 1) {\n      console.log(\"# Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"# Face names: \" + facenames.map((_) => _[1]).join(\" \"));\n      // TODO\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      console.log(\"# Edge names: \" + edgenames.map((_) => _[1]).join(\" \"));\n      // TODO\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      console.log(\"# Vertex names: \" + vertexnames.map((_) => _[1]).join(\" \"));\n    }\n    const geonormals: [Quat, string, string][] = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\n        \"# Distances: face \" +\n          1 +\n          \" edge \" +\n          this.edgedistance +\n          \" vertex \" +\n          this.vertexdistance,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.moveplanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.moveplanes2.slice();\n    // we want to use Math.random() here but we can't, because when\n    // we call multiple times we'll get different orbits/layouts.\n    // to resolve this, we use a very simple linear congruential\n    // generator.  for our purposes, the numbers don't need to be\n    // very random.\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536.0));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Faces is now \" + faces.length);\n    }\n    this.stickersperface = faces.length;\n    // the faces when rotated don't preserve the vertex order at this\n    // point.  to improve 3d rendering speed, we would like to preserve\n    // vertex order on rotation.  First, let's see what rotations preserve\n    // the base face; these are the ones we want to work with.\n    const simplerot: Quat[] = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array<boolean>(faces.length);\n    const sortme: [number, Quat, number][] = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm.dist(sortme[kk][1]) < eps) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    this.shortedge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortedge) {\n          this.shortedge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(\"# Short edge is \" + this.shortedge);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      // try to set Reid order of the cubies within an orbit\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n      if (!sawedge && !sawvertex) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  private keyface(face: Face): string {\n    return this.keyface2(face.centermass());\n  }\n\n  private keyface2(cm: Quat): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + (t % 47));\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s =\n            s +\n            sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) +\n            sfcc(33 + 47 + (Math.floor((t - 47) / 47) % 47)) +\n            sfcc(33 + (t % 47));\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n\n  // same as above, but instead of returning an encoded string, return\n  // an array with offsets.\n  private keyface3(face: Face): number[] {\n    const cm = face.centermass();\n    // take a face and figure out the sides of each move plane\n    const r = [];\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n\n  private findface(cm: Quat): number {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash.get(key)!;\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash.get(key)![i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  private project2d(\n    facen: number,\n    edgen: number,\n    targvec: Quat[],\n  ): [Quat, Quat, Quat] {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    const t1 = tstart(\"allstickers\");\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Total stickers is now \" + this.faces.length);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = this.faces[i].centermass();\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (const q of this.moveplanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.moveplanes2) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Move plane sets: \" + sizes);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos: [string, string, string, string, number][] = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geonormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"SkewbMapper\" &&\n        moveplanesets[0].length === 1\n      ) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (\n          moveplanesets[0].length === 2 &&\n          moveplanesets[0][0].a === 0.333333333333333 &&\n          moveplanesets[0][1].a === 1.66666666666667\n        ) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const facelisthash = new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s)!;\n        arr.push(i);\n        //  If we find a core cubie, split it up into multiple cubies,\n        //  because ksolve doesn't handle orientations that are not\n        //  cyclic, and the rotation group of the core is not cyclic.\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = s + \" \" + suff;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.facelisthash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubies: \" + facelisthash.size);\n    }\n    const cubies: number[][] = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        // this is the original \"cubie\" of a split core; we ignore it.\n        continue;\n      }\n      //  Sort the faces around each corner so they are counterclockwise.  Only\n      //  relevant for cubies that actually are corners (three or more\n      //  faces).  In general cubies might have many faces; for icosohedrons\n      //  there are five faces on the corner cubies.\n      if (facelist.length > 1) {\n        const cm = facelist.map((_: number) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1000) {\n            throw new Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        let mini = 0;\n        let minf = facelist[mini];\n        for (let i = 1; i < facelist.length; i++) {\n          const temp = facelist[i];\n          if (\n            this.faceprecedence[this.getfaceindex(temp)] <\n            this.faceprecedence[this.getfaceindex(minf)]\n          ) {\n            mini = i;\n            minf = temp;\n          }\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.facetocubie = facetocubie;\n    this.facetoord = facetoord;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm = this.facecentermass[cubies[cind][0]];\n          for (const moverotation of moverotations) {\n            const tq =\n              this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (\n      this.setReidOrder &&\n      4 <= this.stickersperface &&\n      this.stickersperface <= 9\n    ) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\",\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"],\n      ];\n      const reidmap: { [key: number]: number } = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          let mask = 0;\n          for (let k = 0; k < cubie[j].length; k++) {\n            mask |= 1 << (cubie[j].charCodeAt(k) - 65);\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          let mask = 0;\n          for (const cubie of cubies[cubienum]) {\n            mask |=\n              1 <<\n              (this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65);\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.options.fixedPieceType === \"v\" && cubies[i].length > 2) ||\n          (this.options.fixedPieceType === \"e\" && cubies[i].length === 2) ||\n          (this.options.fixedPieceType === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          \"Could not find a cubie of type \" +\n            this.options.fixedPieceType +\n            \" to fix.\",\n        );\n      }\n    }\n    // show the orbits\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubie orbit sizes \" + cubieords);\n    }\n    tend(t1);\n  }\n\n  public unswizzle(mv: Move): Move | null {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return null;\n    }\n    return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  private stringToBlockMove(mv: string): Move {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n\n  public parseMove(\n    move: Move,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const bm = this.notationMapper.notationToInternal(move); // pluggable notation\n    if (bm === null) {\n      throw new Error(\"Bad move \" + move.family);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== undefined || move.outerLayer !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + move.family);\n    }\n    if (move.outerLayer !== undefined) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== undefined) {\n      if (move.outerLayer === undefined) {\n        hislice = move.innerLayer;\n        // big assumption here!  if outerlayer not specified, but inner\n        // layer is (like 2U), we use the case of the family (upper vs\n        // lower) to decide if it should be a slice turn or a wide turn.\n        if (grip <= \"Z\") {\n          // uppercase; slice move\n          loslice = hislice;\n        } else {\n          // lowercase; wide move\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\n        \"Bad slice spec \" +\n          loslice +\n          \" \" +\n          hislice +\n          \" vs \" +\n          this.moveplanesets[msi].length,\n      );\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    return [undefined, msi, loslice, hislice, firstgrip, move.amount];\n  }\n\n  private parsemove(\n    mv: string,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    const t1 = tstart(\"genperms\");\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          if (\n            this.basefaces[i].centermass().dist(this.facecentermass[kk]) < eps\n          ) {\n            const o = this.basefaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (\n              t + b <= moveplaneset.length &&\n              dv > moveplaneset[t + b - 1].a\n            ) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.facetocubie[i], this.facetoord[i]];\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (;;) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.facetocubie[fi2], this.facetoord[fi2]);\n          cm = cm2;\n        }\n        // If an oriented center is moving, we need to figure out\n        // the appropriate new orientation.  Normally we use the cubie\n        // sticker identity to locate, but this doesn't work here.\n        // Instead we need to redo the geometry of the sticker itself\n        // rotating and figure out how that maps to the destination\n        // sticker.\n        //\n        // We only need to do this for central center stickers: those\n        // where the face vertex goes through the center.  The others\n        // don't actually need orientation because they can only be\n        // in one orientation by physical constraints.  (You can't spin\n        // a point or cross sticker on the 5x5x5, for example.)\n        //\n        // This also simplifies things because it means the actual\n        // remapping has the same order as the moves themselves.\n        //\n        // The center may or may not have been duplicated at this point.\n        //\n        // The move moving the center might not be the same modulo as the\n        // center itself.\n        if (\n          b.length > 2 &&\n          this.options.orientCenters &&\n          (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)\n        ) {\n          // is this a real center cubie, around an axis?\n          if (\n            this.facecentermass[i].dist(\n              this.basefaces[this.getfaceindex(i)].centermass(),\n            ) < eps\n          ) {\n            // how does remapping of the face/point set map to the original?\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\",\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moverotations[k][0]);\n              }\n            }\n          }\n        }\n        // b.length == 2 means a sticker is spinning in place.\n        // in this case we add duplicate stickers\n        // so that we can make it animate properly in a 3D world.\n        if (b.length === 2 && this.options.orientCenters) {\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (sc === 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders[k] - ii) % this.movesetorders[k],\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist: [\n        string | undefined,\n        number,\n        number,\n        number,\n        boolean,\n        number,\n      ][] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash.clear();\n    this.facecentermass = [];\n    tend(t1);\n  }\n\n  private getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  private getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    let r: any[] = [];\n    if (this.parsedmovelist !== undefined) {\n      for (const parsedmove of this.parsedmovelist) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.options.vertexMoves && !this.options.allMoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.options.outerBlockMoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.options.outerBlockMoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.options.allMoves && i + i === slices) {\n          continue;\n        }\n        if (this.options.outerBlockMoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (\n            newr[j][0] === o[0] &&\n            newr[j][1] === o[1] &&\n            newr[j + 1] === r[i + 1]\n          ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    // TODO\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return r;\n  }\n\n  private graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 &&\n        (this.options.grayCenters || !this.options.includeCenterOrbits)) ||\n      (ori === 2 &&\n        (this.options.grayEdges || !this.options.includeEdgeOrbits)) ||\n      (ori > 2 &&\n        (this.options.grayCorners || !this.options.includeCornerOrbits))\n    );\n  }\n\n  private skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.options.includeCenterOrbits) ||\n      (ori === 2 && !this.options.includeEdgeOrbits) ||\n      (ori > 2 && !this.options.includeCornerOrbits)\n    );\n  }\n\n  private skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  private header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = \"M_\" + externalName(this.notationMapper, os.movenames[i]);\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      if (doinv) {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().inv().toGap() + \";\");\n      } else {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      \"ip:=[\" +\n        ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").join(\",\") +\n        \"];\",\n    );\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\"): string {\n    const od = this.getOrbitsDef(false);\n    return (\n      this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\")\n    );\n  }\n\n  public getKPuzzleDefinition(\n    fortwisty: boolean = true,\n    includemoves: boolean = true,\n  ): KPuzzleDefinition {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    (internalDefinition as any).experimentalPuzzleDescription =\n      this.puzzleDescription;\n    if (!internalDefinition) {\n      throw new Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n\n  public getMoveFromBits(\n    moverange: number[],\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): PGTransform {\n    const moveorbits: PGOrbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (const len of this.cubieords) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  private omitSet(name: string): boolean {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private diffmvsets(a: any[], b: any[], slices: number, neg: boolean) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (\n            a[i][0] + b[j][1] === slices &&\n            a[i][1] + b[j][0] === slices &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        } else {\n          if (\n            a[i][0] === b[j][0] &&\n            a[i][1] === b[j][1] &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // TODO: This is only public for testing; can we make it private again?\n  public getOrbitsDef(\n    fortwisty: boolean,\n    includemoves: boolean = true,\n  ): PGOrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    if (fortwisty) {\n      for (let i = 0; i < this.cubiesetnames.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames: string[] = [];\n    const setdefs: PGOrbitDef[] = [];\n    // if both a movelist and rotations are needed, eliminate rotations\n    // that do not preserve the movelist.\n    const mps = [];\n    const addrot = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    if (this.options.moveList && this.options.addRotations) {\n      for (let i = 0; i < this.moverotations.length; i++) {\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        // does a rotation around k preserve the move set?\n        for (let i = 0; i < this.moverotations.length; i++) {\n          let nn = this.moveplanenormals[k];\n          for (let ii = 1; ii * 2 <= this.movesetorders[i]; ii++) {\n            nn = nn.rotatepoint(this.moverotations[i][0]);\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.moveplanenormals.length; j++) {\n              if (nn.dist(this.moveplanenormals[j]) < eps) {\n                found = j;\n                break;\n              } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps) {\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw new Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (\n              cmp.length !== mps[k].length ||\n              this.moveplanesets[k].length !==\n                this.moveplanesets[found].length ||\n              this.diffmvsets(\n                cmp,\n                mps[k],\n                this.moveplanesets[found].length,\n                neg,\n              )\n            ) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moverotations.length; i++) {\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders[i] > 3) {\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw new Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      if (addrot[k] !== 0) {\n        mps[k].push([0, this.moveplanesets[k].length]);\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new PGOrbitDef(\n          this.cubieords[i],\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: PGOrbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new PGOrbit(\n          p,\n          o,\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const movenames: string[] = [];\n    const moves: PGTransform[] = [];\n    if (includemoves) {\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        const moveplaneset = this.moveplanesets[k];\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos[k];\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          const mna = getmovename(movesetgeo, movebits, slices);\n          const movename = mna[0];\n          const inverted = mna[1];\n          if (moveset[i + 1] === 1) {\n            movenames.push(movename);\n          } else {\n            movenames.push(movename + moveset[i + 1]);\n          }\n          const mv = this.getMoveFromBits(\n            movebits,\n            moveset[i + 1],\n            inverted,\n            this.cmovesbyslice[k],\n            setmoves,\n            this.movesetorders[k],\n          );\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n    );\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n\n  public getScramble(n: number = 0): KTransformationData {\n    const od = this.getOrbitsDef(false);\n    return od.transformToKTransformationData(od.getScrambleTransformation(n));\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  private getOrientationRotation(desiredRotation: any[]): Quat {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(\"Could not find feature \" + feature1name);\n    }\n    if (!feature2) {\n      throw new Error(\"Could not find feature \" + feature2name);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  private getInitial3DRotation(): Quat {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription: FaceBasedOrientationDescription | null = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n\n  private generate2dmapping(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n    twodshrink: number = 0.92,\n  ): (fn: number, q: Quat) => number[] {\n    // generate a mapping to use for 2D for textures, svg\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: Record<string, Quat[]> = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c,\n        ];\n      }\n    };\n    return mappt2d;\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return (\n        '<polygon id=\"' +\n        id +\n        '\" class=\"sticker\" style=\"fill: ' +\n        color +\n        '\" points=\"' +\n        pts.map((p) => p[0] + \" \" + p[1]).join(\" \") +\n        '\"/>\\n'\n      );\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubie[i];\n        const cubieori = this.facetoord[i];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id =\n          this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html =\n      '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") +\n      \"</svg>\";\n    return html;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(options?: { stickerColors?: string[] }): StickerDat {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist: number = 0.52 * this.basefaces[0].get(0).len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = this.basefaces[i].rotate(rot);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubie[i];\n      const cubieori = this.facetoord[i];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie)\n        ? \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum,\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (const gn of this.geonormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order,\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order,\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1.0);\n    const g = (function () {\n      const irot = rot.invrot();\n      return function (facenum: number, coords: number[]): number[] {\n        let q = new Quat(\n          0,\n          coords[0] * maxdist,\n          -coords[1] * maxdist,\n          coords[2] * maxdist,\n        );\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    })().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g },\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geonormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n\n  public textForTwizzleExplorer(): string {\n    return `Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`;\n  }\n\n  writeSchreierSims(tw: (s: string) => void) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n}\n\nexport class PGNotation {\n  private orbitNames: string[];\n  constructor(private pg: PuzzleGeometry, od: PGOrbitsDef) {\n    this.orbitNames = od.orbitnames;\n  }\n\n  public lookupMove(move: Move): KTransformationData | null {\n    const mv = this.pg.parseMove(move);\n    // if a move list subset is defined, don't return moves outside the subset.\n    if (this.pg.parsedmovelist) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedmovelist) {\n        if (\n          parsedmove[1] === mv[1] &&\n          parsedmove[2] === mv[2] &&\n          parsedmove[3] === mv[3] &&\n          parsedmove[4] === mv[4]\n        ) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n}\n"],"names":["constructor","facenames","gripnames_arg","prefixFree","gripnames","this","i","length","j","startsWith","setGripNames","names","splitByFaceNames","s","r","at","currentMatch","substr","Error","push","joinByFaceIndices","list","sep","join","spinmatch","userinput","longname","e1","e2","found","e","spinmatchv","endsWith","slice","unswizzle","upperCaseGrip","toUpperCase","g","notationToInternal","move","notationToExternal","child","sw","family","innerLayer","outerLayer","Move","QuantumMove","amount","fam","substring","internalNames","externalNames","convertString","grip","a","b","suffix","upper","isLowerCase","toLowerCase","convert","ngrip","Math","abs","slices","pyraminxFamilyMap","U","L","R","B","u","l","Uv","Lv","Rv","Bv","D","F","BL","BR","tetraminxFamilyMap","d","f","bl","br","pyraminxFamilyMapWCA","pyraminxExternalQuantumY","pyraminxInternalQuantumY","wcaHack","map","newFamilyWCA","newFamily","isIdentical","quantum","external","internal","Object","entries","PyraminxNotationMapper","super","skewbFamilyMap","UL","UR","ULv","Fv","URv","Dv","skewbExternalQuantumX","skewbInternalQuantumX","skewbInternalQuantumXPrime","skewbExternalQuantumY","skewbInternalQuantumY","skewbInternalQuantumYPrime","skewbExternalQuantumZ","skewbInternalQuantumZ","skewbInternalQuantumZPrime","parseOptions","argv","argp","options","option","addRotations","allMoves","outerBlockMoves","vertexMoves","includeCornerOrbits","includeEdgeOrbits","fixedOrientation","includeCenterOrbits","excludeOrbits","split","moveList","optimizeOrbits","scrambleAmount","fixedPieceType","orientCenters","puzzleOrientation","JSON","parse","puzzleDescription","parsePuzzleDescription","verbosity","grayCorners","grayCenters","grayEdges","puzzleOrientations","assign","zeroCache","iotaCache","zeros","n","c","Array","iota","identity","Perm","factorial","BigInt","gcd","t","m","lcm","p","toString","mul","p2","rmul","inv","compareTo","toGap","cyc","seen","incyc","order","cs","size","mod","reassemblySize","lastGlobalDefinitionCounter","externalName","mapper","moveString","mv","mv2","orbitnames","orbitdefs","solved","movenames","moveops","transformToKTransformationData","mp","orbits","toKPuzzle","toKsolve","name","NullMapper","result","appendDefinition","name2","doinv","toKPuzzleDefinition","includemoves","start","numPieces","numOrientations","startTransformation","pieces","permutation","orientation","moves","startStateData","optimize","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","changed","k","perm","ori","union","keepori","duo","o","find","nontriv","multiple","h","no","on","nv","PGOrbitDef","remapVS","remap","killOri","PGOrbitsDef","VisibleState","_","PGTransform","scramble","getScrambleTransformation","pool","floor","random","ri","rj","rm","orimod","_PGOrbit","newPerm","newOri","equal","toPerm","identicalPieces","done","v","isIdentity","zeroOris","nextNew","reassign","ov","useVS","concise","newori","kcache","PGOrbit","internalMul","newOrbits","internalInv","orbit","perms","PGTransformBase","mulScalar","heads","ah","bh","showcanon","disp","orders","commutes","permA","bits","permB","curlev","sum","nextlev","uniq","sti","st","cnt","nst","PGPuzzles","eps","centermassface","face","Quat","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","q","dist","hypot","len","cross","dot","normalize","sqrt","makenormal","normalizeplane","sub","angle","acos","invrot","det3x3","a00","a01","a02","a10","a11","a12","a20","a21","a22","rotateplane","orthogonal","ab","ac","ad","pointrotation","unproject","rotatepoint","rotateface","det","side","x","cutface","inout","nface","kk","vk","vkk","r2","pt","cutfaces","faces","nfaces","faceside","sameplane","makecut","eps2","cube","s5","tetrahedron","dodecahedron","d36","PI","dx","dy","dd","cos","sin","icosahedron","ang","octahedron","closure","ns","negns","wasseen","uniqueplanes","planerot","getface","mult","multiply","schreierSims","sgs","sgsi","sgslen","Tk","Tklen","resolve","knutha","knuthb","getsgs","none","sz","tks","sollen","avgs","mults","FactoredNumber","lensum","avg","tstart","tend","coords","get","off","centermass","sx","sy","rotate","Face","rotateforward","left","right","FaceTree","collect","arr","leftfirst","expandfaces","rots","rot","eps3","copyright","permissivieMoveParsing","defaultnets","defaultcolors","BB","C","A","E","BF","I","G","S","H","J","K","M","O","P","N","Q","defaultfaceorders","defaultOrientations","findelement","getPG3DNamedPuzzles","getPuzzleDescriptionString","puzzleName","PUZZLE_BASE_SHAPES","PUZZLE_CUT_TYPES","filter","Boolean","shape","cuts","cutType","distance","parseFloat","getPuzzleGeometryByDesc","desc","parsed","pg","PuzzleGeometry","allstickers","genperms","getPuzzleGeometryByName","getmovename","geo","inverted","movenameFamily","movenamePrefix","String","facename","toCoords","maxdist","toFaceCoords","cmovesbyslice","duplicatedFaces","duplicatedCubies","fixedCubie","net","colors","faceorder","faceprecedence","notationMapper","addNotationMapper","setReidOrder","t1","PuzzleGeometryFullOptions","console","log","header","create","moveplanes","moveplanes2","cubies","rotations","baseplane","baseplanerot","baseplanes","baseFaceCount","baseface","zero","facenormal","edgenormal","vertexnormal","boundary","firstface","edgedistance","vertexdistance","cutplanes","intersects","sawface","sawedge","sawvertex","cut","normal","basefaces","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","el","jj","midpoint","otherfaces","facelist","facenametoindex","faceindextoname","neti","f0","fi","ii","fn2","of","faceplane","jjj","midpoint2","swizzler","FaceNameSwizzler","c1","c2","geonormals","edgename","vertexname","geonormalnames","rotation","moveplane","ft","tar","rval","stickersperface","simplerot","cm","finished","sortme","cm2","sort","f2","shortedge","FaceRenamingMapper","keyface","keyface2","sfcc","fromCharCode","moveplaneset","moveplanesets","dv","keyface3","findface","key","facelisthash","face2","facecentermass","project2d","facen","edgen","targvec","edgen2","plane","x0","olen","y0","delta","cosr","sinr","x1","y1","moveplanenormals","qnormal","moveplanenormal","goodnormal","sizes","moverotations","reverse","sizes2","movesetorders","movesetgeos","gtype","p0","neg","pos","geonormal","NxNxNCubeMapper","SkewbNotationMapper","TetraminxNotationMapper","MegaminxScramblingNotationMapper","FTONotationMapper","Map","suff","s2","set","facetocubie","facetoord","values","cmall","looplimit","mini","minf","temp","getfaceindex","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","getcolorkey","cubienum","cubiesetcubies","cubie","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","moverotation","tq","reidorder","reidmap","mask","charCodeAt","cubieset","newmv","modified","stringToBlockMove","re","RegExp","match","loslice","hislice","parseInt","amountstr","parseMove","bm","fullrotation","msi","geoname","firstgrip","parsemove","slicenum","slicecnts","bhi","axiscmoves","sc","cubiedone","ocm","fi2","face1","face0","parsedmovelist","clear","getboundarygeometry","getmovesets","parsedmove","msg","dep","newr","graybyori","skipbyori","skipcubie","comment","writegap","os","getOrbitsDef","mvs","movename","ip","__","writeksolve","od","getKPuzzleDefinition","fortwisty","internalDefinition","experimentalPuzzleDescription","getMoveFromBits","moverange","setmoves","movesetorder","moveorbits","oris","slicecmoves","mperm","setnum","inc","oinc","lastId","omitSet","excludedSet","diffmvsets","setnames","setdefs","mps","addrot","moveset","nn","cmp","allbits","ind","movesetgeo","movebits","mna","getScramble","getMovesAsPerms","getsolved","getOrientationRotation","desiredRotation","feature1name","z1","direction1","feature2name","x2","y2","z2","direction2","feature1","feature2","feature1geoname","feature2geoname","gn","r1","feature2rot","getInitial3DRotation","basefacecount","orientationDescription","generate2dmapping","w","trim","threed","twodshrink","extendedges","cosa","sina","ndx","boundarygeo","polyn","edges","minx","miny","maxx","maxy","f1","es","esi","min","max","xoff","yoff","geos","bg","edges2","initv","connectat","gfi","thisface","caf0","epi","gf1","gf1i","otherface","mp2","hix","hiy","sc2","mappt2d","fn","xoff2","xmul","generatesvg","drawedges","id","pts","color","colormap","facegeo","facenum","fg","svg","cubieori","cubieord","html","get3d","stickers","stickerColors","ord","fcoords","rotdist","isDup","grips","coordinates","quantumMove","twodmapper","irot","bind","axis","textureMapper","getuv","getGeoNormal","divid","textForTwizzleExplorer","writeSchreierSims","tw","as","ss","orbitNames","lookupMove","pgmv"],"sourceRoot":""}