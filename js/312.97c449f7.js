"use strict";(self["webpackChunkcubing_trivia"]=self["webpackChunkcubing_trivia"]||[]).push([[312],{6312:function(t,e,s){s.r(e),s.d(e,{EXPERIMENTAL_PUZZLE_BASE_SHAPES:function(){return Rt},EXPERIMENTAL_PUZZLE_CUT_TYPES:function(){return Bt},ExperimentalPGNotation:function(){return St},PuzzleGeometry:function(){return Pt},Quat:function(){return tt},getPG3DNamedPuzzles:function(){return Ft},getPuzzleDescriptionString:function(){return kt},getPuzzleGeometryByDesc:function(){return Et},getPuzzleGeometryByName:function(){return At},parseOptions:function(){return B},parsePuzzleDescription:function(){return Dt},schreierSims:function(){return ft}});s(1703);var n=s(7574),i=class{constructor(t,e){this.facenames=t,this.prefixFree=!0,this.gripnames=[],e&&(this.gripnames=e);for(let s=0;this.prefixFree&&s<t.length;s++)for(let e=0;this.prefixFree&&e<t.length;e++)s!==e&&t[s].startsWith(t[e])&&(this.prefixFree=!1)}setGripNames(t){this.gripnames=t}splitByFaceNames(t){const e=[];let s=0;while(s<t.length){s>0&&s<t.length&&"_"===t[s]&&s++;let n=-1;for(let e=0;e<this.facenames.length;e++)t.substr(s).startsWith(this.facenames[e])&&(n<0||this.facenames[e].length>this.facenames[n].length)&&(n=e);if(!(n>=0))throw new Error("Could not split "+t+" into face names.");e.push(n),s+=this.facenames[n].length}return e}joinByFaceIndices(t){let e="";const s=[];for(let n=0;n<t.length;n++)s.push(e),s.push(this.facenames[t[n]]),this.prefixFree||(e="_");return s.join("")}spinmatch(t,e){if(t===e)return!0;try{const s=this.splitByFaceNames(t),n=this.splitByFaceNames(e);if(s.length!==n.length&&s.length<3)return!1;for(let t=0;t<s.length;t++){for(let n=0;n<t;n++)if(s[t]===s[n])return!1;let e=!1;for(let i=0;i<n.length;i++)if(s[t]===n[i]){e=!0;break}if(!e)return!1}return!0}catch(s){return!1}}spinmatchv(t,e){return t.endsWith("v")&&e.endsWith("v")?this.spinmatch(t.slice(0,t.length-1),e.slice(0,e.length-1)):this.spinmatch(t,e)}unswizzle(t){(t.endsWith("v")||t.endsWith("w"))&&t[0]<="Z"&&(t=t.slice(0,t.length-1));const e=t.toUpperCase();for(let s=0;s<this.gripnames.length;s++){const t=this.gripnames[s];if(this.spinmatch(e,t))return t}return t}},o=class{notationToInternal(t){return t}notationToExternal(t){return t}},r=class{constructor(t,e){this.child=t,this.sw=e}notationToInternal(t){if("T"===t.family&&void 0===t.innerLayer&&void 0===t.outerLayer)return new n.A6(new n.mv("FLRv",t.innerLayer,t.outerLayer),t.amount);{const e=this.child.notationToInternal(t);return e}}notationToExternal(t){let e=t.family;return e.length>0&&"v"===e[e.length-1]&&(e=e.substring(0,e.length-1)),this.sw.spinmatch(e,"FLUR")?new n.A6(new n.mv("T",t.innerLayer,t.outerLayer),t.amount):this.child.notationToExternal(t)}},h=class{constructor(t,e){this.internalNames=t,this.externalNames=e}convertString(t,e,s){let n="";(t.endsWith("v")||t.endsWith("v"))&&t<="_"&&(n=t.slice(t.length-1),t=t.slice(0,t.length-1));const i=t.toUpperCase();let o=!1;return t!==i&&(o=!0,t=i),t=s.joinByFaceIndices(e.splitByFaceNames(t)),o&&(t=t.toLowerCase()),t+n}convert(t,e,s){const i=t.family,o=this.convertString(i,e,s);return i===o?t:new n.A6(new n.mv(o,t.innerLayer,t.outerLayer),t.amount)}notationToInternal(t){const e=this.convert(t,this.externalNames,this.internalNames);return e}notationToExternal(t){return this.convert(t,this.internalNames,this.externalNames)}},a=class{constructor(t){this.child=t}notationToInternal(t){if(void 0===t.innerLayer&&void 0===t.outerLayer){if(1===Math.abs(t.amount)){if("R++"===t.family)return new n.A6(new n.mv("L",3,2),-2*t.amount);if("R--"===t.family)return new n.A6(new n.mv("L",3,2),2*t.amount);if("D++"===t.family)return new n.A6(new n.mv("U",3,2),-2*t.amount);if("D--"===t.family)return new n.A6(new n.mv("U",3,2),2*t.amount);if("R_PLUSPLUS_"===t.family)return new n.A6(new n.mv("L",3,2),-2*t.amount);if("D_PLUSPLUS_"===t.family)return new n.A6(new n.mv("U",3,2),-2*t.amount)}if("y"===t.family)return new n.A6("Uv",t.amount)}return this.child.notationToInternal(t)}notationToExternal(t){return"Uv"===t.family?new n.A6(new n.mv("y",t.innerLayer,t.outerLayer),t.amount):"Dv"===t.family?new n.A6("y",-t.amount):this.child.notationToExternal(t)}},l=class{constructor(t){this.slices=t}notationToInternal(t){const e=t.family;return t.innerLayer||t.outerLayer||("x"===e?t=new n.A6("Rv",t.amount):"y"===e?t=new n.A6("Uv",t.amount):"z"===e&&(t=new n.A6("Fv",t.amount)),1===(1&this.slices)&&("E"===e?t=new n.A6(new n.mv("D",(this.slices+1)/2),t.amount):"M"===e?t=new n.A6(new n.mv("L",(this.slices+1)/2),t.amount):"S"===e&&(t=new n.A6(new n.mv("F",(this.slices+1)/2),t.amount))),this.slices>2&&("e"===e?t=new n.A6(new n.mv("D",this.slices-1,2),t.amount):"m"===e?t=new n.A6(new n.mv("L",this.slices-1,2),t.amount):"s"===e&&(t=new n.A6(new n.mv("F",this.slices-1,2),t.amount)))),t}notationToExternal(t){const e=t.family;if(!t.innerLayer&&!t.outerLayer){if("Rv"===e)return new n.A6("x",t.amount);if("Uv"===e)return new n.A6("y",t.amount);if("Fv"===e)return new n.A6("z",t.amount);if("Lv"===e)return new n.A6("x",-t.amount);if("Dv"===e)return new n.A6("y",-t.amount);if("Bv"===e)return new n.A6("z",-t.amount)}return t}},c={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},f={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},u={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},m=new n.mv("y"),p=new n.mv("Dv"),d=class{constructor(t){this.child=t,this.wcaHack=!1,this.map=c}notationToInternal(t){if(this.wcaHack&&2===t.innerLayer&&null===t.outerLayer){const e=u[t.family];if(e)return new n.A6(new n.mv(e,t.innerLayer,t.outerLayer),t.amount)}const e=this.map[t.family];return e?new n.A6(new n.mv(e,t.innerLayer,t.outerLayer),t.amount):m.isIdentical(t.quantum)?new n.A6(p,-t.amount):null}notationToExternal(t){if(this.wcaHack&&2===t.innerLayer&&null===t.outerLayer)for(const[e,s]of Object.entries(u))if(this.child.spinmatch(t.family,s))return new n.A6(new n.mv(e,t.innerLayer,t.outerLayer),t.amount);for(const[e,s]of Object.entries(this.map))if(this.child.spinmatch(t.family,s))return new n.A6(new n.mv(e,t.innerLayer,t.outerLayer),t.amount);return p.isIdentical(t.quantum)?new n.A6(m,-t.amount):null}},g=class extends d{constructor(t){super(t),this.wcaHack=!0,this.map=f}},v={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},b=new n.mv("x"),w=new n.mv("Rv"),y=new n.mv("Lv"),x=new n.mv("y"),z=new n.mv("Uv"),M=new n.mv("Dv"),L=new n.mv("z"),F=new n.mv("Fv"),k=new n.mv("Bv"),R=class{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer||t.outerLayer)return null;const e=v[t.family];return e?new n.A6(new n.mv(e,t.outerLayer,t.innerLayer),t.amount):b.isIdentical(t.quantum)?new n.A6(w,t.amount):x.isIdentical(t.quantum)?new n.A6(z,t.amount):L.isIdentical(t.quantum)?new n.A6(F,t.amount):null}notationToExternal(t){for(const[e,s]of Object.entries(v))if(this.child.spinmatchv(t.family,s))return new n.A6(new n.mv(e,t.innerLayer,t.outerLayer),t.amount);return w.isIdentical(t.quantum)?new n.A6(b,t.amount):y.isIdentical(t.quantum)?new n.A6(b,-t.amount):z.isIdentical(t.quantum)?new n.A6(x,t.amount):M.isIdentical(t.quantum)?new n.A6(x,-t.amount):F.isIdentical(t.quantum)?new n.A6(L,t.amount):k.isIdentical(t.quantum)?new n.A6(L,-t.amount):null}};function B(t){let e=0;const s={};while(e<t.length&&"-"===t[e][0]){const n=t[e++];if("--rotations"===n)s.addRotations=!0;else if("--allmoves"===n)s.allMoves=!0;else if("--outerblockmoves"===n)s.outerBlockMoves=!0;else if("--vertexmoves"===n)s.vertexMoves=!0;else if("--nocorners"===n)s.includeCornerOrbits=!1;else if("--noedges"===n)s.includeEdgeOrbits=!1;else if("--noorientation"===n)s.fixedOrientation=!0;else if("--nocenters"===n)s.includeCenterOrbits=!1;else if("--omit"===n)s.excludeOrbits=t[e].split(","),e++;else if("--moves"===n)s.moveList=t[e].split(","),e++;else if("--optimize"===n)s.optimizeOrbits=!0;else if("--scramble"===n)s.scrambleAmount=100;else if("--fixcorner"===n)s.fixedPieceType="v";else if("--fixedge"===n)s.fixedPieceType="e";else if("--fixcenter"===n)s.fixedPieceType="f";else if("--orientcenters"===n)s.orientCenters=!0;else{if("--puzzleorientation"!==n)throw new Error("Bad option: "+n);s.puzzleOrientation=JSON.parse(t[e]),e++}}const n=Dt(t.slice(e).join(" "));return{puzzleDescription:n,options:s}}var D=class{constructor(t={}){this.verbosity=0,this.allMoves=!1,this.vertexMoves=!1,this.addRotations=!1,this.moveList=null,this.fixedOrientation=!1,this.fixedPieceType=null,this.orientCenters=!1,this.includeCornerOrbits=!0,this.includeCenterOrbits=!0,this.includeEdgeOrbits=!0,this.excludeOrbits=[],this.optimizeOrbits=!1,this.grayCorners=!1,this.grayCenters=!1,this.grayEdges=!1,this.puzzleOrientation=null,this.puzzleOrientations=null,this.scrambleAmount=0,Object.assign(this,t)}},E=[],A=[];function C(t){if(!E[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=0;E[t]=e}return E[t]}function O(t){if(!A[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=s;A[t]=e}return A[t]}function T(t){return new I(O(t))}function U(t){let e=1n;while(t>1)e*=BigInt(t),t--;return e}function P(t,e){if(t>e){const s=t;t=e,e=s}while(t>0){const s=e%t;e=t,t=s}return e}function S(t,e){return t/P(t,e)*e}var I=class{constructor(t){this.n=t.length,this.p=t}toString(){return"Perm["+this.p.join(" ")+"]"}mul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=t.p[this.p[s]];return new I(e)}rmul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=this.p[t.p[s]];return new I(e)}inv(){const t=Array(this.n);for(let e=0;e<this.n;e++)t[this.p[e]]=e;return new I(t)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const n=new Array;for(let t=s;!e[t];t=this.p[t])n.push(1+t),e[t]=!0;t.push("("+n.join(",")+")")}return t.join("")}order(){let t=1;const e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;let n=0;for(let t=s;!e[t];t=this.p[t])n++,e[t]=!0;t=S(t,n)}return t}},N=class{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return U(this.size)*BigInt(this.mod)**BigInt(this.size)}},j=0;function $(t,e){const s=n.A6.fromString(e),i=t.notationToExternal(s);return null===i||s===i?e:i.toString()}var q=class{constructor(t,e,s,n,i){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=n,this.moveops=i}transformToKTransformationData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKPuzzle();return e}static transformToKTransformationData(t,e){const s={};for(let n=0;n<t.length;n++)s[t[n]]=e.orbits[n].toKPuzzle();return s}toKsolve(t,e=new o){const s=[];s.push("Name "+t),s.push("");for(let n=0;n<this.orbitnames.length;n++)s.push(`Set ${this.orbitnames[n]} ${this.orbitdefs[n].size} ${this.orbitdefs[n].mod}`);s.push(""),s.push("Solved");for(let n=0;n<this.orbitnames.length;n++)this.solved.orbits[n].appendDefinition(s,this.orbitnames[n],!1,!1);s.push("End");for(let n=0;n<this.movenames.length;n++){s.push("");let t=$(e,this.movenames[n]),i=!1;"'"===t[t.length-1]&&(i=!0,t=t.substring(0,t.length-1)),s.push("Move "+t);for(let e=0;e<this.orbitnames.length;e++)i?this.moveops[n].orbits[e].inv().appendDefinition(s,this.orbitnames[e],!0):this.moveops[n].orbits[e].appendDefinition(s,this.orbitnames[e],!0);s.push("End")}return s}toKPuzzleDefinition(t){const e={},s={};for(let i=0;i<this.orbitnames.length;i++){e[this.orbitnames[i]]={numPieces:this.orbitdefs[i].size,numOrientations:this.orbitdefs[i].mod};const t=this.solved.orbits[i].toKPuzzle();s[this.orbitnames[i]]={pieces:t.permutation,orientation:t.orientation}}const n={};if(t)for(let i=0;i<this.movenames.length;i++)n[this.movenames[i]]=this.transformToKTransformationData(this.moveops[i]);return{name:"PG3D #"+ ++j,orbits:e,startStateData:s,moves:n}}optimize(){const t=[],e=[],s=[],n=[];for(let i=0;i<this.moveops.length;i++)n.push([]);for(let i=0;i<this.orbitdefs.length;i++){const o=this.orbitdefs[i].mod,r=this.orbitdefs[i].size,h=new Z(r),a=new Array(this.orbitdefs[i].size);for(let t=0;t<r;t++)a[t]=!1;for(let t=0;t<this.moveops.length;t++)for(let e=0;e<r;e++)this.moveops[t].orbits[i].perm[e]===e&&0===this.moveops[t].orbits[i].ori[e]||(a[e]=!0,h.union(e,this.moveops[t].orbits[i].perm[e]));let l=!0;if(o>1){l=!1;const t=new Z(this.orbitdefs[i].size*o);for(let e=0;e<this.moveops.length;e++)for(let s=0;s<r;s++)if(this.moveops[e].orbits[i].perm[s]!==s||0!==this.moveops[e].orbits[i].ori[s])for(let n=0;n<o;n++)t.union(s*o+n,this.moveops[e].orbits[i].perm[s]*o+(n+this.moveops[e].orbits[i].ori[s])%o);for(let e=0;!l&&e<r;e++)for(let s=1;s<o;s++)t.find(e*o)===t.find(e*o+s)&&(l=!0);for(let e=0;!l&&e<r;e++)for(let t=0;t<e;t++)this.solved.orbits[i].perm[e]===this.solved.orbits[i].perm[t]&&(l=!0)}let c=-1,f=!1;for(let t=0;t<this.orbitdefs[i].size;t++)if(a[t]){const e=h.find(t);c<0?c=e:c!==e&&(f=!0)}for(let u=0;u<this.orbitdefs[i].size;u++){if(!a[u])continue;const o=h.find(u);if(o!==u)continue;const r=[],c=[];let m=0;for(let t=0;t<this.orbitdefs[i].size;t++)h.find(t)===u&&(r[m]=t,c[t]=m,m++);if(f?t.push(`${this.orbitnames[i]}_p${u}`):t.push(this.orbitnames[i]),l){e.push(new N(m,this.orbitdefs[i].mod)),s.push(this.solved.orbits[i].remapVS(r,m));for(let t=0;t<this.moveops.length;t++)n[t].push(this.moveops[t].orbits[i].remap(r,c,m))}else{e.push(new N(m,1)),s.push(this.solved.orbits[i].remapVS(r,m).killOri());for(let t=0;t<this.moveops.length;t++)n[t].push(this.moveops[t].orbits[i].remap(r,c,m).killOri())}}}return new q(t,e,new H(s),this.movenames,n.map((t=>new W(t))))}scramble(t){this.solved=this.solved.mul(this.getScrambleTransformation(t))}getScrambleTransformation(t){t<100&&(t=100);const e=[];for(let n=0;n<this.moveops.length;n++)e[n]=this.moveops[n];for(let n=0;n<e.length;n++){const t=Math.floor(Math.random()*e.length),s=e[n];e[n]=e[t],e[t]=s}t<e.length&&(t=e.length);for(let n=0;n<t;n++){const t=Math.floor(Math.random()*e.length),s=Math.floor(Math.random()*e.length),n=Math.floor(Math.random()*this.moveops.length);e[t]=e[t].mul(e[s]).mul(this.moveops[n]),Math.random()<.1&&(e[t]=e[t].mul(this.moveops[n]))}let s=e[0];for(let n=1;n<e.length;n++)s=s.mul(e[n]);return s}reassemblySize(){let t=1n;for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}},G=class{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static e(t,e){return new G(O(t),C(t),e)}mul(t){const e=this.perm.length,s=new Array(e);if(1===this.orimod){for(let n=0;n<e;n++)s[n]=this.perm[t.perm[n]];return new G(s,this.ori,this.orimod)}{const n=new Array(e);for(let i=0;i<e;i++)s[i]=this.perm[t.perm[i]],n[i]=(this.ori[t.perm[i]]+t.ori[i])%this.orimod;return new G(s,n,this.orimod)}}inv(){const t=this.perm.length,e=new Array(t),s=new Array(t);for(let n=0;n<t;n++)e[this.perm[n]]=n,s[this.perm[n]]=(this.orimod-this.ori[n])%this.orimod;return new G(e,s,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(1===t)return new I(this.perm);const e=this.perm.length,s=new Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;e++)s[n*t+e]=t*this.perm[n]+(this.ori[n]+e)%t;return new I(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let n=0;n<e;n++){const i=this.perm[n];if(void 0===t[i]){const o=[n];t[i]=!0;for(let t=n+1;t<e;t++)this.perm[t]===i&&o.push(t);s.push(o)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===O(t)&&this.ori===C(t))return!0;for(let e=0;e<t;e++)if(this.perm[e]!==e||0!==this.ori[e])return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===C(t))return!0;for(let e=0;e<t;e++)if(0!==this.ori[e])return!1;return!0}remap(t,e,s){const n=new Array(s),i=new Array(s);for(let o=0;o<s;o++)n[o]=e[this.perm[t[o]]],i[o]=this.ori[t[o]];return new G(n,i,this.orimod)}remapVS(t,e){const s=new Array(e),n=new Array(e);let i=0;const o=[];for(let r=0;r<e;r++){const e=this.perm[t[r]];void 0===o[e]&&(o[e]=i++),s[r]=o[e],n[r]=this.ori[t[r]]}return new G(s,n,this.orimod)}appendDefinition(t,e,s,n=!0){if((!n||!this.isIdentity())&&(t.push(e),t.push(this.perm.map((t=>t+1)).join(" ")),!this.zeroOris()))if(s){const e=new Array(this.ori.length);for(let t=0;t<e.length;t++)e[this.perm[t]]=this.ori[t];t.push(e.join(" "))}else t.push(this.ori.join(" "))}toKPuzzle(){const t=this.perm.length;return this.isIdentity()?(G.kcache[t]||(G.kcache[t]={permutation:O(t),orientation:C(t)}),G.kcache[t]):{permutation:this.perm,orientation:this.ori}}},K=G;K.kcache=[];var _=class{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(const e of this.orbits)t.push(e.inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(const t of this.orbits)t.killOri();return this}toPerm(){const t=new Array;let e=0;for(const n of this.orbits){const s=n.toPerm();t.push(s),e+=s.n}const s=new Array(e);e=0;for(const n of t){for(let t=0;t<n.n;t++)s[e+t]=e+n.p[t];e+=n.n}return new I(s)}identicalPieces(){const t=[];let e=0;for(const s of this.orbits){const n=s.orimod,i=s.identicalPieces();for(let s=0;s<i.length;s++)t.push(i[s].map((t=>t*n+e)));e+=n*s.perm.length}return t}order(){let t=1;for(const e of this.orbits)t=S(t,e.order());return t}},W=class extends _{constructor(t){super(t)}mul(t){return new W(this.internalMul(t))}mulScalar(t){if(0===t)return this.e();let e=this;t<0&&(e=e.inv(),t=-t);while(0===(1&t))e=e.mul(e),t>>=1;if(1===t)return e;let s=e,n=this.e();while(t>0)1&t&&(n=n.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return n}inv(){return new W(this.internalInv())}e(){return new W(this.orbits.map((t=>K.e(t.perm.length,t.orimod))))}},H=class extends _{constructor(t){super(t)}mul(t){return new H(this.internalMul(t))}},Z=class{constructor(t){this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),n=this.find(e);s<n?this.heads[n]=s:s>n&&(this.heads[s]=n)}};function J(t,e){const s=t.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const n=[],i=[];for(let r=0;r<s;r++){const e=t.moveops[r];n.push(e.order());let o=0;for(let n=0;n<s;n++){if(n===r)continue;const s=t.moveops[n];e.mul(s).equal(s.mul(e))&&(o|=1<<n)}i.push(o)}let o={0:1};for(let r=0;r<100;r++){let t=0;const s={};let h=0;for(const e in o){const r=+e,a=o[r];t+=a,h++;for(let t=0;t<n.length;t++)if(0===(r>>t&1)&&0===(r&i[t]&(1<<t)-1)){const e=r&i[t]|1<<t;void 0===s[e]&&(s[e]=0),s[e]+=(n[t]-1)*a}}e(`${r}: canonseq ${t} states ${h}`),o=s}}var Q={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","icosahedron 2":"i v 0.18759247376021","icosahedron 3":"i v 0.18759247376021 e 0","icosahedron static faces":"i v 0.84","icosahedron moving faces":"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"},V=1e-9;function X(t){let e=new tt(0,0,0,0);for(let s=0;s<t.length;s++)e=e.sum(t[s]);return e.smul(1/t.length)}function Y(t,e,s,n){const i=n[t].intersect3(n[e],n[s]);if(!i)return i;for(let o=0;o<n.length;o++)if(o!==t&&o!==e&&o!==s){const t=n[o].b*i.b+n[o].c*i.c+n[o].d*i.d;if(n[o].a>0&&t>n[o].a||n[o].a<0&&t<n[o].a)return!1}return i}var tt=class{constructor(t,e,s,n){this.a=t,this.b=e,this.c=s,this.d=n}mul(t){return new tt(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return`Q[${this.a},${this.b},${this.c},${this.d}]`}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new tt(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new tt(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new tt(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new tt(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new tt(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new tt(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new tt(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new tt(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,n,i,o,r,h,a){return t*(i*a-o*h)+e*(o*r-n*a)+s*(n*h-i*r)}rotateplane(t){const e=t.mul(new tt(0,this.b,this.c,this.d)).mul(t.invrot());return e.a=this.a,e}orthogonal(){const t=Math.abs(this.b),e=Math.abs(this.c),s=Math.abs(this.d);return t<e&&t<s?this.cross(new tt(0,1,0,0)).normalize():e<t&&e<s?this.cross(new tt(0,0,1,0)).normalize():this.cross(new tt(0,0,0,1)).normalize()}pointrotation(t){const e=this.normalize();if(t=t.normalize(),e.sub(t).len()<V)return new tt(1,0,0,0);let s=e.sum(t);s=s.len()<V?s.orthogonal():s.normalize();const n=e.cross(s);return n.a=e.dot(s),n}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map((t=>t.rotatepoint(this)))}intersect3(t,e){const s=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,e.b,e.c,e.d);return!(Math.abs(s)<V)&&new tt(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,e.a,e.c,e.d)/s,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,e.b,e.a,e.d)/s,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,e.b,e.c,e.a)/s)}side(t){return t>V?1:t<-V?-1:0}cutface(t){const e=this.a;let s=0,n=null;for(let i=0;i<t.length;i++)s|=1<<this.side(t[i].dot(this)-e)+1;if(5===(5&s)){n=[];const s=t.map((t=>this.side(t.dot(this)-e)));for(let i=-1;i<=1;i+=2){const o=[];for(let n=0;n<t.length;n++){s[n]!==i&&0!==s[n]||o.push(t[n]);const r=(n+1)%t.length;if(s[n]+s[r]===0&&0!==s[n]){const s=t[n].dot(this)-e,i=t[r].dot(this)-e,h=s/(s-i),a=t[n].smul(1-h).sum(t[r].smul(h));o.push(a)}}n.push(o)}}return n}cutfaces(t){const e=[];for(let s=0;s<t.length;s++){const n=t[s],i=this.cutface(n);i?(e.push(i[0]),e.push(i[1])):e.push(n)}return e}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const n=this.side(t[s].dot(this)-e);if(0!==n)return n}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<V||e.dist(s.smul(-1))<V}makecut(t){return new tt(t,this.b,this.c,this.d)}},et=1e-9;function st(){const t=Math.sqrt(.5);return[new tt(t,t,0,0),new tt(t,0,t,0)]}function nt(){return[new tt(.5,.5,.5,.5),new tt(.5,.5,.5,-.5)]}function it(){const t=2*Math.PI/10;let e=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const n=Math.sqrt(e*e+s*s);return e/=n,s/=n,[new tt(Math.cos(t),e*Math.sin(t),s*Math.sin(t),0),new tt(.5,.5,.5,.5)]}function ot(){let t=1/6+Math.sqrt(5)/6,e=2/3+Math.sqrt(5)/3;const s=Math.sqrt(t*t+e*e);t/=s,e/=s;const n=2*Math.PI/6;return[new tt(Math.cos(n),t*Math.sin(n),e*Math.sin(n),0),new tt(Math.cos(n),-t*Math.sin(n),e*Math.sin(n),0)]}function rt(){const t=Math.sqrt(.5);return[new tt(.5,.5,.5,.5),new tt(t,0,0,t)]}function ht(t){const e=[new tt(1,0,0,0)];for(let s=0;s<e.length;s++)for(let n=0;n<t.length;n++){const i=t[n].mul(e[s]),o=i.smul(-1);let r=!1;for(let t=0;t<e.length;t++)if(i.dist(e[t])<et||o.dist(e[t])<et){r=!0;break}r||e.push(i)}return e}function at(t,e){const s=[],n=[];for(let i=0;i<e.length;i++){const o=t.rotateplane(e[i]);let r=!1;for(let t=0;t<s.length;t++)if(o.dist(s[t])<et){r=!0;break}r||(s.push(o),n.push(e[i]))}return n}function lt(t){const e=[];for(let s=1;s<t.length;s++)for(let n=s+1;n<t.length;n++){const i=Y(0,s,n,t);if(i){let t=!1;for(let s=0;s<e.length;s++)if(i.dist(e[s])<et){t=!0;break}t||e.push(i)}}for(;;){let s=!1;for(let n=0;n<e.length;n++){const i=(n+1)%e.length;if(t[0].dot(e[n].cross(e[i]))<0){const t=e[n];e[n]=e[i],e[i]=t,s=!0}}if(!s)break}return e}var ct=class{constructor(){this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)while(t%e===0)void 0!==this.mult[e]?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(void 0!==this.mult[t]?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)void 0!==this.mult[e]&&(""!==t&&(t+="*"),t+=e,this.mult[e]>1&&(t+=`^${this.mult[e]}`));return t}};function ft(t,e){const s=t[0].p.length,n=T(s);let i=[],o=[],r=[],h=[],a=[];function l(t){for(let e=t.p.length-1;e>=0;e--){const s=t.p[e];if(s!==e){if(!i[e][s])return!1;t=t.mul(o[e][s])}}return!0}function c(t,e,s){h[t].push(e),a[t].push(s);for(let n=0;n<i[t].length;n++)i[t][n]&&f(t,i[t][n].mul(e),s+r[t][n])}function f(t,e,s){const n=e.p[t];if(!i[t][n]){i[t][n]=e,o[t][n]=e.inv(),r[t][n]=s;for(let n=0;n<h[t].length;n++)f(t,e.mul(h[t][n]),s+a[t][n]);return}const u=e.mul(o[t][n]);l(u)||c(t-1,u,s+r[t][n])}function u(){i=[],o=[],h=[],r=[],a=[];for(let t=0;t<s;t++)i.push([]),o.push([]),r.push([]),h.push([]),a.push([]),i[t][t]=n,o[t][t]=n,r[t][t]=0;let l=0,f=1n;for(let n=0;n<t.length;n++){c(s-1,t[n],1),f=1n;let o=0,a=0;const u=[],m=new ct;for(let t=0;t<s;t++){let e=0,n=0;for(let o=0;o<s;o++)i[t][o]&&(e++,n+=r[t][o],t!==o&&l++);o+=h[t].length,f*=BigInt(e),e>1&&m.multiply(e);const c=n/e;u.push(c),a+=c}e(`${n}: sz ${f} T ${o} sol ${a} none ${l} mults ${m.toString()}`)}return f}return u()}function ut(t){return t}function mt(t){}var pt=class{constructor(t){this.coords=new Array(3*t.length);for(let e=0;e<t.length;e++)this.coords[3*e]=t[e].b,this.coords[3*e+1]=t[e].c,this.coords[3*e+2]=t[e].d;this.length=t.length}get(t){return new tt(0,this.coords[3*t],this.coords[3*t+1],this.coords[3*t+2])}centermass(){let t=0,e=0,s=0;for(let n=0;n<this.length;n++)t+=this.coords[3*n],e+=this.coords[3*n+1],s+=this.coords[3*n+2];return new tt(0,t/this.length,e/this.length,s/this.length)}rotate(t){const e=[];for(let s=0;s<this.length;s++)e.push(this.get(s).rotatepoint(t));return new pt(e)}rotateforward(){const t=[];for(let e=1;e<this.length;e++)t.push(this.get(e));return t.push(this.get(0)),new pt(t)}},dt=class{constructor(t,e,s){this.face=t,this.left=e,this.right=s}split(t){const e=t.cutface(this.face);return null!==e&&(void 0===this.left?(this.left=new dt(e[0]),this.right=new dt(e[1])):(this.left=this.left?.split(t),this.right=this.right?.split(t))),this}collect(t,e){return void 0===this.left?t.push(new pt(this.face)):e?(this.left?.collect(t,!1),this.right?.collect(t,!0)):(this.right?.collect(t,!1),this.left?.collect(t,!0)),t}};function gt(t,e){const s=[];for(const n of t)for(const t of e)s.push(t.rotate(n));return s}var vt=1e-9,bt="PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.",wt=!1;function yt(){return{4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}}function xt(){return{4:{F:"#00ff00",D:"#ffff00",L:"#ff0000",R:"#0000ff"},6:{U:"#ffffff",F:"#00ff00",R:"#ff0000",D:"#ffff00",B:"#0000ff",L:"#ff8000"},8:{U:"#ffffff",F:"#ff0000",R:"#00bb00",D:"#ffff00",BB:"#1122ff",L:"#9524c5",BL:"#ff8800",BR:"#aaaaaa"},12:{U:"#ffffff",F:"#006633",R:"#ff0000",C:"#ffffd0",A:"#3399ff",L:"#660099",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#ffff00",I:"#ff6633",D:"#999999"},20:{R:"#db69f0",C:"#178fde",F:"#23238b",E:"#9cc726",L:"#2c212d",U:"#177fa7",A:"#e0de7f",G:"#2b57c0",I:"#41126b",S:"#4b8c28",H:"#7c098d",J:"#7fe7b4",B:"#85fb74",K:"#3f4bc3",D:"#0ff555",M:"#f1c2c8",O:"#58d340",P:"#c514f2",N:"#14494e",Q:"#8b1be1"}}}function zt(){return{4:["F","D","L","R"],6:["U","D","F","B","L","R"],8:["F","BB","D","U","BR","L","R","BL"],12:["L","E","F","BF","R","I","U","D","BR","A","BL","C"],20:["L","S","E","O","F","B","I","P","R","K","U","D","J","A","Q","H","G","N","M","C"]}}function Mt(){return{4:[["FLR",[0,1,0]],["F",[0,0,1]]],6:[["U",[0,1,0]],["F",[0,0,1]]],8:[["U",[0,1,0]],["F",[0,0,1]]],12:[["U",[0,1,0]],["F",[0,0,1]]],20:[["GUQMJ",[0,1,0]],["F",[0,0,1]]]}}function Lt(t,e){for(let s=0;s<t.length;s++)if(t[s][0].dist(e)<vt)return s;throw new Error("Element not found")}function Ft(){return Q}function kt(t){return Q[t]}var Rt=["c","t","o","d","i"],Bt=["f","v","e"];function Dt(t){const e=t.split(/ /).filter(Boolean);if(e.length%2===0)return null;const s=e[0];if("o"!==s&&"c"!==s&&"i"!==s&&"d"!==s&&"t"!==s)return null;const n=[];for(let i=1;i<e.length;i+=2){if("f"!==e[i]&&"v"!==e[i]&&"e"!==e[i])return null;n.push({cutType:e[i],distance:parseFloat(e[i+1])})}return{shape:s,cuts:n}}function Et(t,e={}){const s=Dt(t);if(null===s)throw new Error("Could not parse the puzzle description");const n=new Pt(s,Object.assign({},{allMoves:!0},e));return n.allstickers(),n.genperms(),n}function At(t,e){return Et(Q[t],e)}function Ct(t,e,s){let n=!1;s-e[1]<e[0]&&(t=[t[2],t[3],t[0],t[1]],e=[s-e[1],s-e[0]],n=!0);let i=t[0],o="";if(0===e[0]&&e[1]===s)i+="v";else if(e[0]===e[1])e[1]>0&&(o=String(e[1]+1));else{if(0!==e[0])throw`We only support slice and outer block moves right now. ${e}`;i=i.toLowerCase(),e[1]>1&&(o=String(e[1]+1))}return[o+i,n]}function Ot(t,e){const s=[];let n=0;while(n<t.length){n>0&&n<t.length&&"_"===t[n]&&n++;let i="";for(const s of e)t.substr(n).startsWith(s[1])&&s[1].length>i.length&&(i=s[1]);if(""===i)throw new Error("Could not split "+t+" into face names.");s.push(i),n+=i.length}return s}function Tt(t,e){return[t.b/e,-t.c/e,t.d/e]}function Ut(t,e){const s=[],n=t.length;for(let i=0;i<n;i++){const o=Tt(t.get(n-i-1),e);s[3*i]=o[0],s[3*i+1]=o[1],s[3*i+2]=o[2]}return s}var Pt=class{constructor(t,e){this.puzzleDescription=t,this.cmovesbyslice=[],this.duplicatedFaces=[],this.duplicatedCubies=[],this.fixedCubie=-1,this.net=[],this.colors=[],this.faceorder=[],this.faceprecedence=[],this.notationMapper=new o,this.addNotationMapper="",this.setReidOrder=!1;const s=ut("genperms");this.options=new D(e),this.options.verbosity>0&&console.log(this.header("# ")),this.create(t),mt(s)}create(t){const{shape:e,cuts:s}=t;this.moveplanes=[],this.moveplanes2=[],this.faces=[],this.cubies=[];let n=null;switch(e){case"c":n=st();break;case"o":n=rt();break;case"i":n=ot();break;case"t":n=nt();break;case"d":n=it();break;default:throw new Error("Bad shape argument: "+e)}this.rotations=ht(n),this.options.verbosity&&console.log("# Rotations: "+this.rotations.length);const o=n[0];this.baseplanerot=at(o,this.rotations);const r=this.baseplanerot.map((t=>o.rotateplane(t)));this.baseplanes=r,this.baseFaceCount=r.length;const a=yt()[r.length];this.net=a,this.colors=xt()[r.length],this.faceorder=zt()[r.length],this.options.verbosity>0&&console.log("# Base planes: "+r.length);const l=lt(r),c=new tt(0,0,0,0);this.options.verbosity>0&&console.log("# Face vertices: "+l.length);const f=r[0].makenormal(),u=l[0].sum(l[1]).makenormal(),m=l[0].makenormal(),p=new tt(1,f.b,f.c,f.d);this.options.verbosity>0&&console.log("# Boundary is "+p);const d=at(p,this.rotations),g=d.map((t=>p.rotateplane(t))),v=lt(g);this.edgedistance=v[0].sum(v[1]).smul(.5).dist(c),this.vertexdistance=v[0].dist(c);const b=[],w=[];let y=!1,x=!1,z=!1;for(const i of s){let t=null,e=0;switch(i.cutType){case"f":t=f,e=1,y=!0;break;case"v":t=m,e=this.vertexdistance,z=!0;break;case"e":t=u,e=this.edgedistance,x=!0;break;default:throw new Error("Bad cut argument: "+i.cutType)}b.push(t.makecut(i.distance)),w.push(i.distance<e)}this.options.addRotations&&(y||b.push(f.makecut(10)),z||b.push(m.makecut(10)),x||b.push(u.makecut(10))),this.basefaces=[];for(const i of this.baseplanerot){const t=i.rotateface(v);this.basefaces.push(new pt(t))}const M=[],L=[],F=[],k=[],R=v.length;function B(t,e,s){for(const n of t)if(n[0].dist(e)<vt)return void n.push(s);t.push([e,s])}for(let i=0;i<this.baseplanerot.length;i++){const t=this.baseplanerot[i].rotateface(v);for(let e=0;e<t.length;e++){const s=(e+1)%t.length,n=t[e].sum(t[s]).smul(.5);B(k,n,i)}}const D=[];for(let i=0;i<this.baseplanerot.length;i++){const t=this.baseplanerot[i].rotateface(v),e=[];for(let s=0;s<t.length;s++){const n=(s+1)%t.length,o=t[s].sum(t[n]).smul(.5),r=k[Lt(k,o)];if(i===r[1])e.push(r[2]);else{if(i!==r[2])throw new Error("Could not find edge");e.push(r[1])}}D.push(e)}const E={},A=[];A.push(a[0][0]),E[a[0][0]]=0,A[D[0][0]]=a[0][1],E[a[0][1]]=D[0][0];for(const i of a){const t=i[0],e=E[t];if(void 0===e)throw new Error("Bad edge description; first edge not connected");let s=-1;for(let n=0;n<D[e].length;n++){const t=A[D[e][n]];if(void 0!==t&&t===i[1]){s=n;break}}if(s<0)throw new Error("First element of a net not known");for(let n=2;n<i.length;n++){if(""===i[n])continue;const t=D[e][(n+s-1)%R],o=A[t];if(void 0!==o&&o!==i[n])throw new Error("Face mismatch in net");A[t]=i[n],E[i[n]]=t}}for(let i=0;i<A.length;i++){let t=!1;for(let e=0;e<this.faceorder.length;e++)if(A[i]===this.faceorder[e]){this.faceprecedence[i]=e,t=!0;break}if(!t)throw new Error("Could not find face "+A[i]+" in face order list "+this.faceorder)}for(let i=0;i<this.baseplanerot.length;i++){const t=this.baseplanerot[i].rotateface(v),e=p.rotateplane(this.baseplanerot[i]),s=A[i];M.push([t,s]),L.push([e,s])}for(let i=0;i<this.baseplanerot.length;i++){const t=this.baseplanerot[i].rotateface(v),e=A[i];for(let s=0;s<t.length;s++){const n=(s+1)%t.length,i=t[s].sum(t[n]).smul(.5),o=(s+2)%t.length,r=t[n].sum(t[o]).smul(.5),h=Lt(k,i),a=Lt(k,r);B(F,t[n],[e,a,h])}}this.swizzler=new i(M.map((t=>t[1])));const C=this.swizzler.prefixFree?"":"_";for(let i=0;i<k.length;i++){if(3!==k[i].length)throw new Error("Bad length in edge names "+k[i]);let t=A[k[i][1]];const e=A[k[i][2]];t=this.faceprecedence[k[i][1]]<this.faceprecedence[k[i][2]]?t+C+e:e+C+t,k[i]=[k[i][0],t]}for(let i=0;i<F.length;i++){if(F[i].length<4)throw new Error("Bad length in vertex names");let t=1;for(let s=2;s<F[i].length;s++)this.faceprecedence[E[F[i][s][0]]]<this.faceprecedence[E[F[i][t][0]]]&&(t=s);let e="";for(let s=1;s<F[i].length;s++){e=1===s?F[i][t][0]:e+C+F[i][t][0];for(let e=1;e<F[i].length;e++)if(F[i][t][1]===F[i][e][2]){t=e;break}}F[i]=[F[i][0],e]}this.options.verbosity>1&&(console.log("# Face precedence list: "+this.faceorder.join(" ")),console.log("# Face names: "+M.map((t=>t[1])).join(" ")),console.log("# Edge names: "+k.map((t=>t[1])).join(" ")),console.log("# Vertex names: "+F.map((t=>t[1])).join(" ")));const O=[];for(const i of L)O.push([i[0].makenormal(),i[1],"f"]);for(const i of k)O.push([i[0].makenormal(),i[1],"e"]);for(const i of F)O.push([i[0].makenormal(),i[1],"v"]);this.facenames=M,this.faceplanes=L,this.edgenames=k,this.vertexnames=F,this.geonormals=O;const T=O.map((t=>t[1]));this.swizzler.setGripNames(T),this.options.verbosity>0&&console.log("# Distances: face 1 edge "+this.edgedistance+" vertex "+this.vertexdistance);for(let i=0;i<b.length;i++)for(const t of this.rotations){const e=b[i].rotateplane(t);let s=!1;for(const t of this.moveplanes)if(e.sameplane(t)){s=!0;break}s||(this.moveplanes.push(e),w[i]&&this.moveplanes2.push(e))}let U=new dt(v);const P=this.moveplanes2.slice();let S=31;for(let i=0;i<P.length;i++){const t=i+Math.floor((P.length-i)*(S/65536));U=U.split(P[t]),P[t]=P[i],S=(1657*S+101)%65536}const I=U.collect([],!0);this.faces=I,this.options.verbosity>0&&console.log("# Faces is now "+I.length),this.stickersperface=I.length;const N=[],j=X(v);for(const i of this.rotations){const t=i.rotateface(v);j.dist(X(t))<vt&&N.push(i)}const $=new Array(I.length),q=[];for(let i=0;i<I.length;i++){const t=I[i].centermass();q.push([j.dist(t),t,i])}q.sort(((t,e)=>t[0]-e[0]));for(let i=0;i<I.length;i++){const t=q[i][2];if(!$[t]){$[t]=!0;for(const e of N){const s=I[t].rotate(e),n=s.centermass();for(let t=i+1;t<I.length;t++){if(q[t][0]-q[i][0]>vt)break;const e=q[t][2];if(!$[e]&&n.dist(q[t][1])<vt){$[e]=!0,I[e]=s;break}}}}}this.shortedge=1e99;for(const i of I)for(let t=0;t<i.length;t++){const e=(t+1)%i.length,s=i.get(t).dist(i.get(e));s<this.shortedge&&(this.shortedge=s)}this.options.verbosity>0&&console.log("# Short edge is "+this.shortedge),"c"!==e||!y||x||z||(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrder=!0),"c"!==e||!z||y||x||(this.addNotationMapper="SkewbMapper"),"t"!==e||!z&&!y||x||(this.addNotationMapper="PyraminxOrTetraminxMapper"),"o"===e&&y&&(this.notationMapper=new h(this.swizzler,new i(["F","D","L","BL","R","U","BR","B"])),x||z||(this.addNotationMapper="FTOMapper")),"d"===e&&y&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new h(this.swizzler,new i(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}keyface(t){return this.keyface2(t.centermass())}keyface2(t){let e="";const s=String.fromCharCode;for(const n of this.moveplanesets)if(n.length>0){const i=t.dot(n[0]);let o=0,r=1;while(2*r<=n.length)r*=2;for(;r>0;r>>=1)o+r<=n.length&&i>n[o+r-1].a&&(o+=r);if(o<47)e+=s(33+o);else if(o<2256)e=e+s(80+Math.floor(o/47)-1)+s(33+o%47);else{if(!(o<106079))throw Error("Too many slices for cubie encoding");e=e+s(80+Math.floor((o-47)/2209-1))+s(80+Math.floor((o-47)/47)%47)+s(33+o%47)}}return e}keyface3(t){const e=t.centermass(),s=[];for(const n of this.moveplanesets)if(n.length>0){const t=e.dot(n[0]);let i=0,o=1;while(2*o<=n.length)o*=2;for(;o>0;o>>=1)i+o<=n.length&&t>n[i+o-1].a&&(i+=o);s.push(i)}return s}findface(t){const e=this.keyface2(t),s=this.facelisthash.get(e);if(1===s.length)return s[0];for(let n=0;n+1<s.length;n++){const s=this.facelisthash.get(e)[n];if(Math.abs(t.dist(this.facecentermass[s]))<vt)return s}return s[s.length-1]}project2d(t,e,s){const n=this.facenames[t][0],i=(e+1)%n.length,o=this.baseplanes[t];let r=n[i].sub(n[e]);const h=r.len();r=r.normalize();const a=r.cross(o).normalize();let l=s[1].sub(s[0]);const c=l.len()/h;l=l.normalize();const f=l.b,u=l.c,m=r.smul(f).sub(a.smul(u)).smul(c),p=a.smul(f).sum(r.smul(u)).smul(c),d=new tt(0,s[0].b-m.dot(n[e]),s[0].c-p.dot(n[e]),0);return[m,p,d]}allstickers(){const t=ut("allstickers");this.faces=gt(this.baseplanerot,this.faces),this.options.verbosity>0&&console.log("# Total stickers is now "+this.faces.length),this.facecentermass=new Array(this.faces.length);for(let r=0;r<this.faces.length;r++)this.facecentermass[r]=this.faces[r].centermass();const e=[],s=[];for(const r of this.moveplanes){const t=r.makenormal();let n=!1;for(const e of s)t.sameplane(e.makenormal())&&(n=!0);n||(s.push(t),e.push([]))}for(const r of this.moveplanes2){const t=r.makenormal();for(let n=0;n<s.length;n++)if(t.sameplane(s[n])){e[n].push(r);break}}for(let r=0;r<e.length;r++){const t=e[r].map((t=>t.normalizeplane())),n=s[r];for(let e=0;e<t.length;e++)t[e].makenormal().dist(n)>vt&&(t[e]=t[e].smul(-1));t.sort(((t,e)=>t.a-e.a)),e[r]=t}this.moveplanesets=e,this.moveplanenormals=s;const n=e.map((t=>t.length));this.options.verbosity>0&&console.log("# Move plane sets: "+n);const i=[];for(let r=0;r<e.length;r++)i.push([]);for(const r of this.rotations){if(Math.abs(Math.abs(r.a)-1)<vt)continue;const t=r.makenormal();for(let n=0;n<e.length;n++)if(t.sameplane(s[n])){i[n].push(r);break}}this.moverotations=i;for(let r=0;r<i.length;r++){const t=i[r],e=t[0].makenormal();for(let s=0;s<t.length;s++)e.dist(t[s].makenormal())>vt&&(t[s]=t[s].smul(-1));t.sort(((t,e)=>t.angle()-e.angle())),i[r][0].dot(s[r])<0&&t.reverse()}const o=i.map((t=>1+t.length));this.movesetorders=o;const h=[];let c="?";for(let A=0;A<e.length;A++){const t=s[A];let n=null,i=null;for(const e of this.geonormals){const s=t.dot(e[0]);Math.abs(s-1)<vt?(i=[e[1],e[2]],c=e[2]):Math.abs(s+1)<vt&&(n=[e[1],e[2]],c=e[2])}if(null===i||null===n)throw new Error("Saw positive or negative sides as null");h.push([i[0],i[1],n[0],n[1],1+e[A].length]),"NxNxNCubeMapper"===this.addNotationMapper&&"f"===c&&(this.notationMapper=new l(1+e[A].length),this.addNotationMapper=""),"SkewbMapper"===this.addNotationMapper&&1===e[0].length&&(this.notationMapper=new R(this.swizzler),this.addNotationMapper=""),"PyraminxOrTetraminxMapper"===this.addNotationMapper&&(2===e[0].length&&.333333333333333===e[0][0].a&&1.66666666666667===e[0][1].a?(this.notationMapper=new d(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new g(this.swizzler),this.addNotationMapper="")),"MegaminxMapper"===this.addNotationMapper&&"f"===c&&(1+e[A].length===3&&(this.notationMapper=new a(this.notationMapper)),this.addNotationMapper=""),"FTOMapper"===this.addNotationMapper&&"f"===c&&(1+e[A].length===3&&(this.notationMapper=new r(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=h;const f=new Map,u=this.faces;for(let r=0;r<u.length;r++){const t=u[r],e=this.keyface(t);if(f.get(e)){const t=f.get(e);if(t.push(r),t.length===this.baseFaceCount){this.options.verbosity>0&&console.log("# Splitting core.");for(let s=0;s<t.length;s++){const n=e+" "+s;f.set(n,[t[s]])}}}else f.set(e,[r])}this.facelisthash=f,this.options.verbosity>0&&console.log("# Cubies: "+f.size);const m=[],p=[],v=[];for(const r of f.values())if(r.length!==this.baseFaceCount){if(r.length>1){const t=r.map((t=>u[t].centermass())),e=X(t);for(let i=0;r.length>2;i++){let s=!1;for(let n=0;n<r.length;n++){const i=(n+1)%r.length;if(e.dot(t[n].cross(t[i]))<0){const e=t[n];t[n]=t[i],t[i]=e;const o=r[n];r[n]=r[i],r[i]=o,s=!0}}if(!s)break;if(i>1e3)throw new Error("Bad epsilon math; too close to border")}let s=0,n=r[s];for(let i=1;i<r.length;i++){const t=r[i];this.faceprecedence[this.getfaceindex(t)]<this.faceprecedence[this.getfaceindex(n)]&&(s=i,n=t)}if(0!==s){const t=r.slice();for(let e=0;e<r.length;e++)r[e]=t[(s+e)%r.length]}}for(let t=0;t<r.length;t++){const e=r[t];p[e]=m.length,v[e]=t}m.push(r)}this.cubies=m,this.facetocubie=p,this.facetoord=v;const b=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],w=[],y=[0,0,0,0,0,0],x=[],z=[];let M=0;const L=[],F=[],k=[],B=[],D=t=>m[t].map((t=>this.getfaceindex(t))).join(" "),E=[];for(let r=0;r<m.length;r++){if(z[r])continue;const t=m[r];if(0===t.length)continue;const e={};let s=0;k.push(0),E.push([]);const n=t.length,o=y[n]++;let h=b[n];void 0!==h&&n!==this.baseFaceCount||(h="CORE"),h+=0===o?"":o+1,w[M]=h,x[M]=n;const a=[r];let l=0;z[r]=!0;while(l<a.length){const n=a[l++],o=D(n);if((t.length>1||void 0===e[o])&&(e[o]=s++),B[n]=e[o],L[n]=M,E[M].push(n),F[n]=k[M]++,a.length<this.rotations.length){const t=this.facecentermass[m[n][0]];for(const e of i){const s=this.facetocubie[this.findface(t.rotatepoint(e[0]))];z[s]||(a.push(s),z[s]=!0)}}}M++}if(this.setReidOrder&&4<=this.stickersperface&&this.stickersperface<=9){const t=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],e={};for(const s of t)for(let t=0;t<s.length;t++){let n=0;for(let e=0;e<s[t].length;e++)n|=1<<s[t].charCodeAt(e)-65;e[n]=t}for(const s of E)for(const t of s){let s=0;for(const e of m[t])s|=1<<this.facenames[this.getfaceindex(e)][1].charCodeAt(0)-65;F[t]=e[s]}}if(this.cubiesetnums=L,this.cubieordnums=F,this.cubiesetnames=w,this.cubieords=k,this.orbitoris=x,this.cubievaluemap=B,this.cubiesetcubies=E,null!==this.options.fixedPieceType){for(let t=0;t<m.length;t++)if("v"===this.options.fixedPieceType&&m[t].length>2||"e"===this.options.fixedPieceType&&2===m[t].length||"f"===this.options.fixedPieceType&&1===m[t].length){this.fixedCubie=t;break}if(this.fixedCubie<0)throw new Error("Could not find a cubie of type "+this.options.fixedPieceType+" to fix.")}this.options.verbosity>0&&console.log("# Cubie orbit sizes "+k),mt(t)}unswizzle(t){const e=this.notationMapper.notationToInternal(t);return null===e?null:e.modified({family:this.swizzler.unswizzle(e.family)})}stringToBlockMove(t){const e=RegExp("^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$"),s=t.match(e);if(null===s)throw new Error("Bad move passed "+t);const i=s[4];let o,r;if(void 0!==s[2]){if(void 0===s[3])throw new Error("Missing second number in range");o=parseInt(s[2],10)}void 0!==s[3]&&(r=parseInt(s[3],10));let h="1",a=1;return void 0!==s[5]&&(h=s[5],"'"===h[0]&&(h="-"+h.substring(1)),a=parseInt(h,10)),new n.A6(new n.mv(i,r,o),a)}parseMove(t){const e=this.notationMapper.notationToInternal(t);if(null===e)throw new Error("Bad move "+t.family);t=e;let s,n=t.family,i=!1;if(n.endsWith("v")&&n[0]<="Z"){if(void 0!==t.innerLayer||void 0!==t.outerLayer)throw new Error("Cannot use a prefix with full cube rotations");n=n.slice(0,-1),i=!0}n.endsWith("w")&&n[0]<="Z"&&(n=n.slice(0,-1).toLowerCase());let o=-1;const r=this.swizzler.unswizzle(n);let h=!1;for(let c=0;c<this.movesetgeos.length;c++){const t=this.movesetgeos[c];r===t[0]&&(h=!0,s=t,o=c),r===t[2]&&(h=!1,s=t,o=c)}let a=1,l=1;if(n.toUpperCase()!==n&&(l=2),void 0===s)throw new Error("Bad grip in move "+t.family);if(void 0!==t.outerLayer&&(a=t.outerLayer),void 0!==t.innerLayer&&(void 0===t.outerLayer?(l=t.innerLayer,a=n<="Z"?l:1):l=t.innerLayer),a--,l--,i&&(a=0,l=this.moveplanesets[o].length),a<0||a>this.moveplanesets[o].length||l<0||l>this.moveplanesets[o].length)throw new Error("Bad slice spec "+a+" "+l+" vs "+this.moveplanesets[o].length);if(!wt&&0===a&&l===this.moveplanesets[o].length&&!i)throw new Error("! full puzzle rotations must be specified with v suffix.");return[void 0,o,a,l,h,t.amount]}parsemove(t){const e=this.parseMove(this.stringToBlockMove(t));return e[0]=t,e}genperms(){const t=ut("genperms");if(this.cmovesbyslice.length>0)return;const e=[];if(this.options.orientCenters)for(let s=0;s<this.cubies.length;s++)if(1===this.cubies[s].length){const t=this.cubies[s][0],e=this.getfaceindex(t);if(this.basefaces[e].centermass().dist(this.facecentermass[t])<vt){const n=this.basefaces[e].length;for(let t=1;t<n;t++)this.cubies[s].push(this.cubies[s][t-1]);this.duplicatedFaces[t]=n,this.duplicatedCubies[s]=n,this.orbitoris[this.cubiesetnums[s]]=n}}for(let s=0;s<this.moveplanesets.length;s++){const t=this.moveplanesets[s],n=[],i=[t.length+1,0];let o=1;while(2*o<=t.length)o*=2;for(let e=0;e<this.faces.length;e++){let s=0;if(t.length>0){const n=this.facecentermass[e].dot(t[0]);for(let e=o;e>0;e>>=1)s+e<=t.length&&n>t[s+e-1].a&&(s+=e);s=t.length-s}n.push(s);while(i.length<=s)i.push(0);i[s]++}const r=new Array(i.length);for(let e=0;e<i.length;e++)r[e]=[];const h=[];for(let e=0;e<this.faces.length;e++){if(n[e]<0)continue;const t=[this.facetocubie[e],this.facetoord[e]];let i=this.facecentermass[e];const o=i;let a=e;const l=n[a];for(;;){n[a]=-1;const e=i.rotatepoint(this.moverotations[s][0]);if(e.dist(o)<vt)break;a=this.findface(e),t.push(this.facetocubie[a],this.facetoord[a]),i=e}if(t.length>2&&this.options.orientCenters&&(1===this.cubies[t[0]].length||this.duplicatedCubies[t[0]]>1)&&this.facecentermass[e].dist(this.basefaces[this.getfaceindex(e)].centermass())<vt){let e=this.faces[this.cubies[t[0]][0]];for(let n=0;n<t.length;n+=2){const i=this.faces[this.cubies[t[n]][0]];let o=-1;for(let t=0;t<e.length;t++)if(i.get(t).dist(e.get(0))<vt){o=t;break}if(o<0)throw new Error("Couldn't find rotation of center faces; ignoring for now.");t[n+1]=o,e=e.rotate(this.moverotations[s][0])}}if(2===t.length&&this.options.orientCenters)for(let e=1;e<this.movesetorders[s];e++)0===l?t.push(t[0],e):t.push(t[0],(this.movesetorders[s]-e)%this.movesetorders[s]);if(t.length>2&&!h[t[0]]){if(t.length!==2*this.movesetorders[s])throw new Error("Bad length in perm gen");for(const e of t)r[l].push(e)}for(let e=0;e<t.length;e+=2)h[t[e]]=!0}for(let e=0;e<r.length;e++)r[e]=r[e].slice();e.push(r)}if(this.cmovesbyslice=e,this.options.moveList){const t=[];for(const e of this.options.moveList)t.push(this.parsemove(e));this.parsedmovelist=t}this.facelisthash.clear(),this.facecentermass=[],mt(t)}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(t){const e=this.moveplanesets[t].length;let s=[];if(void 0!==this.parsedmovelist)for(const n of this.parsedmovelist)n[1]===t&&(n[4]?s.push([n[2],n[3]]):s.push([e-n[3],e-n[2]]),s.push(n[5]));else if(this.options.vertexMoves&&!this.options.allMoves){const n=this.movesetgeos[t];if(n[1]!==n[3])for(let t=0;t<e;t++)"v"!==n[1]?(this.options.outerBlockMoves?s.push([t+1,e]):s.push([t+1]),s.push(1)):(this.options.outerBlockMoves?s.push([0,t]):s.push([t,t]),s.push(1))}else for(let n=0;n<=e;n++)(this.options.allMoves||n+n!==e)&&(this.options.outerBlockMoves?n+n>e?s.push([n,e]):s.push([0,n]):s.push([n,n]),s.push(1));if(this.fixedCubie>=0){const n=this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[t],i=[];for(let t=0;t<s.length;t+=2){let o=s[t];if(n>=o[0]&&n<=o[1])if(0===o[0])o=[o[1]+1,e];else{if(e!==o[1])throw Error("fixed cubie option would disconnect move");o=[0,o[0]-1]}let r=!1;for(let e=0;e<i.length;e+=2)if(i[e][0]===o[0]&&i[e][1]===o[1]&&i[e+1]===s[t+1]){r=!0;break}r||(i.push(o),i.push(s[t+1]))}s=i}return s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&(this.options.grayCenters||!this.options.includeCenterOrbits)||2===e&&(this.options.grayEdges||!this.options.includeEdgeOrbits)||e>2&&(this.options.grayCorners||!this.options.includeCornerOrbits)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&!this.options.includeCenterOrbits||2===e&&!this.options.includeEdgeOrbits||e>2&&!this.options.includeCornerOrbits}skipcubie(t){return this.skipbyori(t)}header(t){return t+bt+"\n"+t+"\n"}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let i=0;i<t.moveops.length;i++){let n="M_"+$(this.notationMapper,t.movenames[i]),o=!1;"'"===n[n.length-1]&&(n=n.substring(0,n.length-1),o=!0),s.push(n),o?e.push(n+":="+t.moveops[i].toPerm().inv().toGap()+";"):e.push(n+":="+t.moveops[i].toPerm().toGap()+";")}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const n=t.solved.identicalPieces();return e.push("ip:=["+n.map((t=>"["+t.map((t=>t+1)).join(",")+"]")).join(",")+"];"),e.push("# Size(Group(Gen));"),e.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));"),e.push(""),this.header("# ")+e.join("\n")}writeksolve(t="PuzzleGeometryPuzzle"){const e=this.getOrbitsDef(!1);return this.header("# ")+e.toKsolve(t,this.notationMapper).join("\n")}getKPuzzleDefinition(t=!0,e=!0){const s=this.getOrbitsDef(t,e),n=s.toKPuzzleDefinition(e);if(n.experimentalPuzzleDescription=this.puzzleDescription,!n)throw new Error("Missing definition!");return n}getMoveFromBits(t,e,s,n,i,o){const r=[],h=[],a=[];for(const f of this.cubieords)h.push(O(f)),a.push(C(f));for(let f=t[0];f<=t[1];f++){const t=n[f];for(let e=0;e<t.length;e+=2*o){const n=t.slice(e,e+2*o),i=this.cubiesetnums[n[0]];for(let t=0;t<n.length;t+=2)n[t]=this.cubieordnums[n[t]];let r=2,l=3;s&&(r=n.length-2,l=n.length-1),h[i]===O(this.cubieords[i])&&(h[i]=h[i].slice(),this.orbitoris[i]>1&&!this.options.fixedOrientation&&(a[i]=a[i].slice()));for(let t=0;t<n.length;t+=2)h[i][n[(t+r)%n.length]]=n[t],this.orbitoris[i]>1&&!this.options.fixedOrientation&&(a[i][n[t]]=(n[(t+l)%n.length]-n[(t+1)%n.length]+2*this.orbitoris[i])%this.orbitoris[i])}}let l=new K(O(24),C(24),1);for(let f=0;f<this.cubiesetnames.length;f++)if(!i||i[f])if(1===this.orbitoris[f]||this.options.fixedOrientation)h[f]===O(l.perm.length)?(h[f]!==l.perm&&(l=new K(h[f],a[f],1)),r.push(l)):r.push(new K(h[f],a[f],1));else{const t=new Array(a[f].length);for(let e=0;e<h[f].length;e++)t[e]=a[f][h[f][e]];r.push(new K(h[f],t,this.orbitoris[f]))}let c=new W(r);return 1!==e&&(c=c.mulScalar(e)),c}omitSet(t){for(const e of this.options.excludeOrbits)if(e===t)return!0;return!1}diffmvsets(t,e,s,n){for(let i=0;i<t.length;i+=2){let o=!1;for(let r=0;!o&&r<e.length;r+=2)n?t[i][0]+e[r][1]===s&&t[i][1]+e[r][0]===s&&t[i+1]===e[r+1]&&(o=!0):t[i][0]===e[r][0]&&t[i][1]===e[r][1]&&t[i+1]===e[r+1]&&(o=!0);if(!o)return!0}return!1}getOrbitsDef(t,e=!0){const s=[];if(t)for(let f=0;f<this.cubiesetnames.length;f++)s.push(1);const n=[],i=[],o=[],r=[];for(let f=0;f<this.moveplanesets.length;f++){const t=this.getmovesets(f);o.push(t),this.options.addRotations?r.push(1):r.push(0)}if(this.options.moveList&&this.options.addRotations){for(let t=0;t<this.moverotations.length;t++)r[t]=0;for(let t=0;t<this.moveplanesets.length;t++)for(let e=0;e<this.moverotations.length;e++){let s=this.moveplanenormals[t];for(let n=1;2*n<=this.movesetorders[e];n++){if(s=s.rotatepoint(this.moverotations[e][0]),r[e]&n)continue;let i=-1,h=!1;for(let t=0;t<this.moveplanenormals.length;t++){if(s.dist(this.moveplanenormals[t])<vt){i=t;break}if(s.dist(this.moveplanenormals[t].smul(-1))<vt){i=t,h=!0;break}}if(i<0)throw new Error("Could not find rotation");const a=o[i];(a.length!==o[t].length||this.moveplanesets[t].length!==this.moveplanesets[i].length||this.diffmvsets(a,o[t],this.moveplanesets[i].length,h))&&(r[e]|=n)}}for(let t=0;t<this.moverotations.length;t++)if(0===r[t])r[t]=1;else if(1===r[t])this.movesetorders[t]>3?r[t]=2:r[t]=0;else{if(3!==r[t])throw new Error("Impossible addrot val");r[t]=0}}for(let f=0;f<this.moveplanesets.length;f++)0!==r[f]&&(o[f].push([0,this.moveplanesets[f].length]),o[f].push(r[f]));for(let f=0;f<this.moveplanesets.length;f++){const t=o[f],e=this.movesetorders[f];for(let s=0;s<t.length;s+=2)for(let e=0;e<s;e+=2)if(t[s]===t[e]&&t[s+1]===t[e+1])throw new Error("Redundant moves in moveset.");const n=[];for(let s=0;s<t.length;s+=2)for(let e=t[s][0];e<=t[s][1];e++)n[e]=1;const i=this.cmovesbyslice[f];for(let o=0;o<i.length;o++){if(1!==n[o])continue;const t=i[o];for(let n=0;n<t.length;n+=2*e){if(this.skipcubie(t[n]))continue;const e=this.cubiesetnums[t[n]];s[e]=1}}}for(let f=0;f<this.cubiesetnames.length;f++)s[f]&&(this.omitSet(this.cubiesetnames[f])?s[f]=0:(n.push(this.cubiesetnames[f]),i.push(new N(this.cubieords[f],this.options.fixedOrientation?1:this.orbitoris[f]))));const h=[];for(let f=0;f<this.cubiesetnames.length;f++){if(!s[f])continue;if(this.omitSet(this.cubiesetnames[f]))continue;const e=[],n=[];for(let s=0;s<this.cubieords[f];s++){if(t)e.push(s);else{const t=this.cubiesetcubies[f][s];e.push(this.cubievaluemap[t])}n.push(0)}h.push(new K(e,n,this.options.fixedOrientation?1:this.orbitoris[f]))}const a=[],l=[];if(e)for(let f=0;f<this.moveplanesets.length;f++){const t=this.moveplanesets[f],e=t.length,n=o[f],i=this.movesetgeos[f];for(let o=0;o<n.length;o+=2){const t=n[o],r=Ct(i,t,e),h=r[0],c=r[1];1===n[o+1]?a.push(h):a.push(h+n[o+1]);const u=this.getMoveFromBits(t,n[o+1],c,this.cmovesbyslice[f],s,this.movesetorders[f]);l.push(u)}}let c=new q(n,i,new H(h),a,l);return this.options.optimizeOrbits&&(c=c.optimize()),0!==this.options.scrambleAmount&&c.scramble(this.options.scrambleAmount),c}getScramble(t=0){const e=this.getOrbitsDef(!1);return e.transformToKTransformationData(e.getScrambleTransformation(t))}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map((t=>t.toPerm()))}showcanon(t){J(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.baseFaceCount;e++)for(let s=0;s<this.stickersperface;s++)t.push(e);return new I(t)}getOrientationRotation(t){const[e,[s,n,i]]=t[0],o=new tt(0,s,-n,i),[r,[h,a,l]]=t[1],c=new tt(0,h,-a,l);let f=null,u=null;const m=this.swizzler.unswizzle(e),p=this.swizzler.unswizzle(r);for(const b of this.geonormals)m===b[1]&&(f=b[0]),p===b[1]&&(u=b[0]);if(!f)throw new Error("Could not find feature "+e);if(!u)throw new Error("Could not find feature "+r);const d=f.pointrotation(o),g=u.rotatepoint(d),v=g.unproject(o).pointrotation(c.unproject(o));return v.mul(d)}getInitial3DRotation(){const t=this.baseFaceCount;let e=null;if(this.options.puzzleOrientation?e=this.options.puzzleOrientation:this.options.puzzleOrientations&&(e=this.options.puzzleOrientations[t]),e||(e=Mt()[t]),!e)throw new Error("No default orientation?");return this.getOrientationRotation(e)}generate2dmapping(t=800,e=500,s=10,n=!1,i=.92){function o(t,e){let s=t[1][0]-t[0][0],n=t[1][1]-t[0][1];const i=2*Math.PI/e,o=Math.cos(i),r=Math.sin(i);for(let h=2;h<e;h++){const e=s*o+n*r;n=n*o-s*r,s=e,t.push([t[h-1][0]+s,t[h-1][1]+n])}}t-=2*s,e-=2*s,this.genperms();const r=this.getboundarygeometry(),h=r.facenames[0][0],a=h.length,l=this.net;if(null===l)throw new Error("No net?");const c={};let f=0,u=0,m=1,p=0;c[l[0][0]]=[[1,0],[0,0]],o(c[l[0][0]],a);for(const B of l){const t=B[0];if(!c[t])throw new Error("Bad edge description; first edge not connected.");for(let e=1;e<B.length;e++){const s=B[e];""===s||c[s]||(c[s]=[c[t][e%a],c[t][(e+a-1)%a]],o(c[s],a))}}for(const B in c){const t=c[B];for(const e of t)f=Math.min(f,e[0]),m=Math.max(m,e[0]),u=Math.min(u,e[1]),p=Math.max(p,e[1])}const d=Math.min(t/(m-f),e/(p-u)),g=.5*(t-d*(m+f)),v=.5*(e-d*(p+u)),b={},w=this.getboundarygeometry(),y={},x=[[d+g,v],[g,v]];y[l[0][0]]=x,o(y[l[0][0]],a),b[this.facenames[0][1]]=this.project2d(0,0,[new tt(0,x[0][0],x[0][1],0),new tt(0,x[1][0],x[1][1],0)]);const z=[];z[0]=0;for(const B of l){const t=B[0];if(!y[t])throw new Error("Bad edge description; first edge not connected.");let e=-1;for(let n=0;n<w.facenames.length;n++)if(t===w.facenames[n][1]){e=n;break}if(e<0)throw new Error("Could not find first face name "+t);const s=w.facenames[e][0];for(let n=1;n<B.length;n++){const i=B[n];if(""===i||y[i])continue;y[i]=[y[t][n%a],y[t][(n+a-1)%a]],o(y[i],a);const r=z[e],h=s[(r+n)%a].sum(s[(r+n+a-1)%a]).smul(.5),l=Lt(w.edgenames,h),c=w.edgenames[l][1],f=Ot(c,this.facenames),u=f[t===f[0]?1:0];let m=-1;for(let t=0;t<w.facenames.length;t++)if(u===w.facenames[t][1]){m=t;break}if(m<0)throw new Error("Could not find second face name");const p=w.facenames[m][0];for(let e=0;e<p.length;e++){const s=p[e].sum(p[(e+1)%a]).smul(.5);if(s.dist(h)<=vt){const s=y[t][(n+a-1)%a],i=y[t][n%a];z[m]=e,b[u]=this.project2d(m,e,[new tt(0,i[0],i[1],0),new tt(0,s[0],s[1],0)]);break}}}}let M=0,L=0;const F=this.getInitial3DRotation();for(let B of this.faces){n&&(B=B.rotate(F));for(let t=0;t<B.length;t++)M=Math.max(M,Math.abs(B.get(t).b)),L=Math.max(L,Math.abs(B.get(t).c))}const k=Math.min(e/L/2,(t-s)/M/4),R=(o,r)=>{if(n){r=r.rotatepoint(F);const n=.5*s+.25*t,i=this.baseplanes[o].rotateplane(F).d<0?1:-1;return[s+.5*t+i*(n-r.b*k),s+.5*e+r.c*k]}{const t=b[this.facenames[o][1]];return[s+i*r.dot(t[0])+t[2].b,s+e-i*r.dot(t[1])-t[2].c]}};return R}generatesvg(t=800,e=500,s=10,n=!1){const i=this.generate2dmapping(t,e,s,n);function o(t,e,s){return'<polygon id="'+t+'" class="sticker" style="fill: '+s+'" points="'+e.map((t=>t[0]+" "+t[1])).join(" ")+'"/>\n'}const r=this.getsolved(),h=[],a=[];for(let f=0;f<this.baseFaceCount;f++)h[f]=this.colors[this.facenames[f][1]];for(let f=0;f<this.faces.length;f++){const t=this.faces[f],e=Math.floor(f/this.stickersperface),s=[];for(let n=0;n<t.length;n++)s.push(i(e,t.get(n)));a.push(s)}const l=[];for(let f=0;f<this.baseFaceCount;f++){l.push("<g>"),l.push("<title>"+this.facenames[f][1]+"</title>\n");for(let t=0;t<this.stickersperface;t++){const e=f*this.stickersperface+t,s=this.facetocubie[e],n=this.facetoord[e],i=this.cubiesetnums[s],c=this.cubieordnums[s],u=this.graybyori(s)?"#808080":h[r.p[e]];let m=this.cubiesetnames[i]+"-l"+c+"-o"+n;if(l.push(o(m,a[e],u)),this.duplicatedFaces[e])for(let t=1;t<this.duplicatedFaces[e];t++)m=this.cubiesetnames[i]+"-l"+c+"-o"+t,l.push(o(m,a[e],u))}l.push("</g>")}const c='<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">\n<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n'+l.join("")+"</svg>";return c}get3d(t){const e=[],s=this.getInitial3DRotation(),i=[],o=.52*this.basefaces[0].get(0).len();for(let n=0;n<this.basefaces.length;n++){const t=this.basefaces[n].rotate(s),e=this.facenames[n][1];i.push({coords:Ut(t,o),name:e})}for(let n=0;n<this.faces.length;n++){const i=Math.floor(n/this.stickersperface),r=this.facetocubie[n],h=this.facetoord[n],a=this.cubiesetnums[r],l=this.cubieordnums[r];let c=this.graybyori(r)?"#808080":this.colors[this.facenames[i][1]];t?.stickerColors&&(c=t.stickerColors[n]);const f=this.faces[n].rotate(s);e.push({coords:Ut(f,o),color:c,orbit:this.cubiesetnames[a],ord:l,ori:h,face:i});let u=f;if(this.duplicatedFaces[n]){const t=u.length/this.duplicatedFaces[n];for(let s=1;s<this.duplicatedFaces[n];s++){for(let e=0;e<t;e++)u=u.rotateforward();e.push({coords:Ut(u,o),color:c,orbit:this.cubiesetnames[a],ord:l,ori:s,face:i,isDup:!0})}}}const r=[];for(let l=0;l<this.movesetgeos.length;l++){const t=this.movesetgeos[l],e=this.movesetorders[l];for(const i of this.geonormals)t[0]===i[1]&&t[1]===i[2]&&(r.push({coordinates:Tt(i[0].rotatepoint(s),1),quantumMove:new n.A6(t[0]),order:e}),r.push({coordinates:Tt(i[0].rotatepoint(s).smul(-1),1),quantumMove:new n.A6(t[2]),order:e}))}const h=this.generate2dmapping(2880,2160,0,!1,1),a=function(){const t=s.invrot();return function(e,s){let n=new tt(0,s[0]*o,-s[1]*o,s[2]*o);n=n.rotatepoint(t);const i=h(e,n);return i[0]/=2880,i[1]=1-i[1]/2160,i}}().bind(this);return{stickers:e,faces:i,axis:r,unswizzle:this.unswizzle.bind(this),notationMapper:this.notationMapper,textureMapper:{getuv:a}}}getGeoNormal(t){const e=this.getInitial3DRotation(),s=this.swizzler.unswizzle(t);for(const n of this.geonormals)if(s===n[1]){const t=Tt(n[0].rotatepoint(e),1);return Math.abs(t[0])<vt&&Math.abs(t[2])<vt&&(t[0]=0,t[2]=1e-6),t}}getfaceindex(t){const e=this.stickersperface;return Math.floor(t/e)}textForTwizzleExplorer(){return`Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`}writeSchreierSims(t){const e=this.getOrbitsDef(!1),s=e.reassemblySize();t(`Reassembly size is ${s}`);const n=ft(this.getMovesAsPerms(),t),i=s/n;t(`Ratio is ${i}`)}},St=class{constructor(t,e){this.pg=t,this.orbitNames=e.orbitnames}lookupMove(t){const e=this.pg.parseMove(t);if(this.pg.parsedmovelist){let t=!1;for(const s of this.pg.parsedmovelist)s[1]===e[1]&&s[2]===e[2]&&s[3]===e[3]&&s[4]===e[4]&&(t=!0);if(!t)return null}let s=[e[2],e[3]];if(!e[4]){const t=this.pg.moveplanesets[e[1]].length;s=[t-e[3],t-e[2]]}const n=this.pg.getMoveFromBits(s,e[5],!e[4],this.pg.cmovesbyslice[e[1]],void 0,this.pg.movesetorders[e[1]]),i=q.transformToKTransformationData(this.orbitNames,n);return i}};s(2230)}}]);
//# sourceMappingURL=312.97c449f7.js.map